Directory structure:
└── shpigford-society-fail/
    ├── README.md
    ├── browserconfig.xml
    ├── index.html
    ├── LICENSE
    ├── site.webmanifest
    ├── javascript/
    │   ├── achievements.js
    │   ├── actions.js
    │   ├── automation.js
    │   ├── contentment.js
    │   ├── core.js
    │   ├── farming.js
    │   ├── game.js
    │   ├── hunting.js
    │   ├── log.js
    │   ├── lumbermill.js
    │   ├── medicaltent.js
    │   ├── party.js
    │   ├── randomevents.js
    │   ├── settings.js
    │   ├── shortcuts-modal.js
    │   ├── shortcuts.js
    │   ├── specializations.js
    │   ├── storage.js
    │   ├── technologies.js
    │   ├── time.js
    │   ├── tutorial.js
    │   ├── upgrades.js
    │   ├── utils.js
    │   ├── watchtower.js
    │   └── well.js
    ├── stylesheets/
    │   ├── achievements.css
    │   ├── actions.css
    │   ├── base.css
    │   ├── buttons.css
    │   ├── contentment.css
    │   ├── core.css
    │   ├── farming.css
    │   ├── gameover.css
    │   ├── hunting.css
    │   ├── icons.css
    │   ├── log.css
    │   ├── lumbermill.css
    │   ├── modal.css
    │   ├── modules.css
    │   ├── party.css
    │   ├── reset.css
    │   ├── settings.css
    │   ├── shell.css
    │   ├── shortcuts.css
    │   ├── start.css
    │   ├── technologies.css
    │   ├── typography.css
    │   ├── upgrades.css
    │   ├── utils.css
    │   ├── watchtower.css
    │   └── well.css
    └── .cursor/
        └── rules/
            ├── css.mdc
            ├── dev-rules.mdc
            ├── game-mechanics.mdc
            ├── javascript.mdc
            └── todo.mdc

================================================
FILE: README.md
================================================
# Society Fail

Society Fail is a browser-based incremental clicker game built by [@Shpigford](https://twitter.com/Shpigford).

It was built almost exclusively using AI.

![Society Fail Screenshot](https://github.com/user-attachments/assets/db69a8df-b3bf-456d-9607-1f3192008640)

## Running locally

I've tried to keep it as simple as possible. No build process. No dependencies. Just pure, post-apocalyptic partying.

Due to the use of ES6 modules, you can't just open the `index.html` file in your browser. You have to run a local server. I recommend using [Live Server](https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer) for VSCode/Cursor as it makes it ridiculously easy without having to install anything else.

## Contributing

Want to contribute? Please do! Just open an issue for feature requests or submit a PR.

The `docs/gamedesign.md` is a solid file to reference when using AI to make changes/additions as it contains a lot of rules/logic/best practices for this type of game.

## License & Copyright

Released under the MIT license, see the [LICENSE](https://github.com/Shpigford/society-fail/blob/main/LICENSE) file. Copyright (c) Sabotage Media LLC.



================================================
FILE: browserconfig.xml
================================================
<?xml version="1.0" encoding="utf-8"?>
<browserconfig>
    <msapplication>
        <tile>
            <square150x150logo src="/mstile-150x150.png"/>
            <TileColor>#000000</TileColor>
        </tile>
    </msapplication>
</browserconfig>



================================================
FILE: index.html
================================================
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Society Fail</title>
  <meta name="description"
    content="Can you survive the apocalypse? Society Fail is a post-apocalyptic incremental game where you must scavenge for resources, fight off mutants, and navigate a world where civilization has fallen apart.">
  <link rel="stylesheet" href="stylesheets/core.css">

  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#be5046">
  <meta name="msapplication-TileColor" content="#000000">
  <meta name="theme-color" content="#000000">
  <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
</head>

<body>
  <div id="game_start_screen">
    <div class="splash_screen">

      <header>
        <i data-lucide="skull" class="icon"></i>
        <div>
          <h1>Society Fail</h1>
          <h2>Can you survive the apocalypse?</h2>
        </div>
      </header>

      <section>
        <button data-difficulty="easy">
          <span class="shortcut">a</span>
          <b>Easy</b>
          <div>
            <span class="food"><b></b> <i data-lucide="beef" class="icon red"></i></span>
            <span class="water"><b></b> <i data-lucide="droplet" class="icon blue"></i></span>
            <span class="wood"><b></b> <i data-lucide="tree-pine" class="icon green"></i></span>
          </div>
        </button>
        <button data-difficulty="medium">
          <span class="shortcut">s</span>
          <b>Medium</b>
          <div>
            <span class="food"><b></b> <i data-lucide="beef" class="icon red"></i></span>
            <span class="water"><b></b> <i data-lucide="droplet" class="icon blue"></i></span>
            <span class="wood"><b></b> <i data-lucide="tree-pine" class="icon green"></i></span>
          </div>
        </button>
        <button data-difficulty="hard">
          <span class="shortcut">d</span>
          <b>Hard</b>
          <div>
            No resources <i data-lucide="circle-slash-2" class="icon red"></i>
          </div>
        </button>
      </section>

      <footer>
        <p>Society Fail is <a href="https://github.com/Shpigford/society-fail" target="_blank">open source</a> and made
          by
          <a href="https://x.com/shpigford" target="_blank">@shpigford</a>!
        </p>
      </footer>
    </div>
  </div>

  <div id="game_screen" class="hidden">
    <header>
      <div class="logo">
        <i data-lucide="skull" class="icon red"></i>
        <h1>Society Fail</h1>
      </div>
      <div class="resources">
        <div class="resource"><i data-lucide="beef" class="icon dark-yellow"></i><span>0</span></div>
        <div class="resource"><i data-lucide="droplet" class="icon blue"></i><span>0</span></div>
        <div class="resource"><i data-lucide="tree-pine" class="icon green"></i><span>0</span></div>
        <div class="resource"><i data-lucide="book" class="icon magenta"></i><span>0</span></div>
      </div>
      <div class="time-module">
        <div id="contentment-display" class="contentment-display">
          <i data-lucide="smile" class="icon light-green"></i>
          <span>Content</span>
        </div>
        <div class="time-display">
          <div class="day-night-indicator"></div>
          <span id="time">Day 1, Hour 1</span>
        </div>
        <div class="button-container">
          <button id="shortcuts-help">
            <span class="shortcut">h</span>
            <i data-lucide="keyboard" class="icon"></i>
          </button>
          <button id="pause-game"><i data-lucide="pause" class="icon"></i></button>
          <button id="reset-game"><i data-lucide="rotate-ccw" class="icon"></i></button>
        </div>
      </div>
    </header>

    <section id="actions-module">
      <button id="gatherFoodBtn" class="action-button">
        <span class="shortcut">q</span>
        <i data-lucide="beef" class="icon dark-yellow"></i>
        <span>Gather Food</span>
      </button>
      <button id="collectWaterBtn" class="action-button">
        <span class="shortcut">w</span>
        <i data-lucide="droplet" class="icon blue"></i>
        <span>Collect Water</span>
      </button>
      <button id="chopWoodBtn" class="action-button">
        <span class="shortcut">e</span>
        <i data-lucide="tree-pine" class="icon green"></i>
        <span>Chop Wood</span>
      </button>
    </section>

    <section id="party-container">
      <h2><i data-lucide="users" class="icon-dark"></i> Your Party</h2>
      <div id="party-display"></div>
    </section>

    <div id="game-modules">
      <div id="main-modules">
        <section id="log-module">
          <h2 class="collapsible"><i data-lucide="cctv" class="icon-dark"></i> Activity Log <i data-lucide="chevron-up"
              class="toggle-icon"></i></h2>
          <div class="module-content">
            <div id="log-content"></div>
          </div>
        </section>

        <section id="upgrades-module">
          <h2 class="collapsible"><i data-lucide="book-plus" class="icon-dark"></i> Upgrades <i data-lucide="chevron-up"
              class="toggle-icon"></i></h2>
          <div class="module-content">
            <div id="upgrades"></div>
          </div>
        </section>

        <section id="achievements-module">
          <h2 class="collapsible"><i data-lucide="trophy" class="icon-dark"></i> Achievements <i
              data-lucide="chevron-up" class="toggle-icon"></i></h2>
          <div class="module-content">
            <div id="achievements"></div>
          </div>
        </section>
      </div>

      <div id="secondary-modules">
        <section id="technology-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Ancient Knowledge</div>
            <div class="description">What secrets await those who seek to understand?</div>
          </div>
        </section>
        <section id="farming-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Mysterious Crops</div>
            <div class="description">What secrets lie beneath the soil?</div>
          </div>
        </section>
        <section id="well-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Hidden Waters</div>
            <div class="description">Is there a source of life nearby?</div>
          </div>
        </section>
        <section id="hunting-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Mysterious Tracks</div>
            <div class="description">What creatures roam these lands?</div>
          </div>
        </section>
        <section id="lumber-mill-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Untamed Forest</div>
            <div class="description">How can we harness nature's bounty?</div>
          </div>
        </section>
        <section id="watchtower-module" class="mystery">
          <div class="mystery-content">
            <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
            <div class="title">Unexplored Horizon</div>
            <div class="description">What lies beyond our sight?</div>
          </div>
        </section>
      </div>
    </div>

    <footer>
      <p>Society Fail is <a href="https://github.com/Shpigford/society-fail" target="_blank">open source</a> and made
        by
        <a href="https://x.com/shpigford" target="_blank">@shpigford</a>!
      </p>
    </footer>
  </div>

  <div id="game_over_screen" class="hidden">
    <div id="game_over_content"></div>
  </div>

  <script src="https://unpkg.com/lucide@latest"></script>
  <script type="module" src="javascript/core.js"></script>
</body>

</html>


================================================
FILE: LICENSE
================================================
MIT License

Copyright (c) Sabotage Media LLC

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.



================================================
FILE: site.webmanifest
================================================
{
    "name": "",
    "short_name": "",
    "icons": [
        {
            "src": "/android-chrome-192x192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "/android-chrome-512x512.png",
            "sizes": "512x512",
            "type": "image/png"
        }
    ],
    "theme_color": "#000000",
    "background_color": "#000000",
    "display": "standalone"
}



================================================
FILE: javascript/achievements.js
================================================
import { gameState } from './settings.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';
import { UPGRADES } from './settings.js';

/**
 * Defines the list of achievements in the game.
 * Each achievement has an id, name, description, and a condition function.
 * @type {Array<Object>}
 */
export const ACHIEVEMENTS = [
  { id: 'survivor', name: 'Survivor', description: 'Survive for 7 days', condition: state => state.day >= 7 },
  { id: 'wellFed', name: 'Well Fed', description: 'Accumulate 1000 food', condition: state => state.totalResourcesGathered.food >= 1000 },
  { id: 'hydrated', name: 'Hydrated', description: 'Accumulate 1000 water', condition: state => state.totalResourcesGathered.water >= 1000 },
  { id: 'lumberjack', name: 'Lumberjack', description: 'Accumulate 1000 wood', condition: state => state.totalResourcesGathered.wood >= 1000 },
  { id: 'farmer', name: 'Farmer', description: 'Start a farm', condition: state => state.upgrades.farming },
  { id: 'hunter', name: 'Hunter', description: 'Build the Hunting Lodge', condition: state => state.upgrades.huntingLodge },
  { id: 'wellDriller', name: 'Well Driller', description: 'Build the Well', condition: state => state.upgrades.well },
  { id: 'doctor', name: 'Doctor', description: 'Build the Medical Tent', condition: state => state.upgrades.medicalTent },
  { id: 'toolMaker', name: 'Tool Maker', description: 'Build the Tool Workshop', condition: state => state.upgrades.toolWorkshop },
  { id: 'waterPurifier', name: 'Water Purifier', description: 'Build the Water Purification System', condition: state => state.upgrades.waterPurification },
  { id: 'masterFarmer', name: 'Master Farmer', description: 'Unlock Advanced Farming Techniques', condition: state => state.upgrades.advancedFarming },
  { id: 'bigFamily', name: 'Big Family', description: 'Have 10 people in your party', condition: state => state.party.length >= 10 },
  { id: 'efficient', name: 'Efficient', description: 'Perform 100 actions', condition: state => state.totalActions >= 100 },
  { id: 'wellStocked', name: 'Well Stocked', description: 'Have 500 of each resource at once', condition: state => state.food >= 500 && state.water >= 500 && state.wood >= 500 },
  { id: 'marathon', name: 'Marathon', description: 'Play for 24 hours', condition: state => state.totalPlayTime >= 24 * 60 * 60 },
  { id: 'cropMaster', name: 'Crop Master', description: 'Harvest 100 crops', condition: state => state.totalCropsHarvested >= 100 },
  { id: 'bigGame', name: 'Big Game Hunter', description: 'Successfully hunt 50 animals', condition: state => state.totalAnimalsHunted >= 50 },
  { id: 'waterWizard', name: 'Water Wizard', description: 'Collect 1000 water from the well', condition: state => state.totalWellWaterCollected >= 1000 },
  { id: 'survivor30', name: 'Long-term Survivor', description: 'Survive for 30 days', condition: state => state.day >= 30 },
  { id: 'jackOfAllTrades', name: 'Jack of All Trades', description: 'Unlock all upgrades', condition: state => Object.keys(UPGRADES).every(upgradeId => state.upgrades[upgradeId]) },
];

/**
 * Checks for newly unlocked achievements and unlocks them if conditions are met.
 */
export function checkAchievements() {
  ACHIEVEMENTS.forEach(achievement => {
    if (!gameState.achievements[achievement.id] && achievement.condition(gameState)) {
      unlockAchievement(achievement.id);
    }
  });
}

/**
 * Unlocks an achievement by its ID.
 * @param {string} achievementId - The ID of the achievement to unlock.
 */
function unlockAchievement(achievementId) {
  const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);
  if (achievement) {
    gameState.achievements[achievementId] = true;
    addLogEntry(`Achievement Unlocked: ${achievement.name}!`, 'success');
    updateAchievementsUI();
  }
}

/**
 * Returns an array of unlocked achievements.
 * @returns {Array<Object>} An array of unlocked achievement objects.
 */
export function getUnlockedAchievements() {
  return ACHIEVEMENTS.filter(achievement => gameState.achievements[achievement.id]);
}

/**
 * Initializes the achievements in the game state.
 */
export function initializeAchievements() {
  gameState.achievements = gameState.achievements || {};
  ACHIEVEMENTS.forEach(achievement => {
    gameState.achievements[achievement.id] = gameState.achievements[achievement.id] || false;
  });
  updateAchievementsUI();
}

/**
 * Updates the achievements UI.
 */
export function updateAchievementsUI() {
  const achievementsContainer = document.getElementById('achievements');
  if (!achievementsContainer) return;

  achievementsContainer.innerHTML = ACHIEVEMENTS.map(createAchievementElement).join('');
  createLucideIcons();
}

/**
 * Creates an HTML element for an achievement.
 * @param {Object} achievement - The achievement object.
 * @returns {string} HTML string for the achievement element.
 */
function createAchievementElement(achievement) {
  const isUnlocked = gameState.achievements[achievement.id];
  return `
    <div class="achievement-item ${isUnlocked ? 'achievement-unlocked' : 'achievement-locked'}">
      <div class="achievement-icon">
        <i data-lucide="${isUnlocked ? 'check-circle' : 'circle'}" class="icon"></i>
      </div>
      <div class="achievement-info">
        <div class="achievement-name">${achievement.name}</div>
        <div class="achievement-description">${achievement.description}</div>
      </div>
    </div>
  `;
}


================================================
FILE: javascript/actions.js
================================================
import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { checkUpgradeAvailability } from './upgrades.js';
import { getContentmentEffects } from './contentment.js';
import { getSpecializationBonus } from './specializations.js';

/**
 * Selects the best available party member for an action.
 * @returns {Object|null} An object containing the selected member and their index, or null if no member is available.
 */
function selectBestPartyMember() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  return gameState.party.reduce((best, member, index) => {
    const isBusy = gameState.busyUntil[index] > currentTime;
    const isResting = gameState.busyUntil[index] === -1;
    if (!member.isDead && !isBusy && !isResting && (!best || member.energy > best.member.energy)) {
      return { member, index };
    }
    return best;
  }, null);
}

/**
 * Performs a resource gathering action.
 * @param {string} resourceType - The type of resource to gather ('food', 'water', or 'wood').
 * @param {number} minAmount - The minimum amount of resource that can be gathered.
 * @param {number} maxAmount - The maximum amount of resource that can be gathered.
 */
function performResourceAction(resourceType, minAmount, maxAmount) {
  const selected = selectBestPartyMember();
  if (!selected) {
    console.log(`No available party members to gather ${resourceType}.`);
    addLogEntry(`Failed to gather ${resourceType}: No available party members.`, 'warning');
    if (gameState.party.every(member => member.isDead)) {
      addLogEntry("All party members are dead. Game over!", 'error');
      gameOver();
    }
    return;
  }

  // Apply contentment effects to resource gathering
  const contentmentEffects = getContentmentEffects();
  const contentmentModifier = 1 + (contentmentEffects.resourceEfficiency || 0);

  // Apply specialization bonus if the member is a gatherer
  const specializationModifier = getSpecializationBonus(selected.member.specialization, resourceType);

  // Calculate base amount
  let amountGathered = Math.floor(Math.random() * (maxAmount - minAmount + 1)) + minAmount;

  // Apply contentment and specialization modifiers
  amountGathered = Math.max(1, Math.floor(amountGathered * contentmentModifier * specializationModifier));

  gameState[resourceType] += amountGathered;
  gameState.totalResourcesGathered[resourceType] += amountGathered;
  gameState.totalActions++;

  // 5% chance to gain 1 knowledge point
  if (Math.random() < 0.05) {
    gameState.knowledgePoints += 1;
    gameState.totalKnowledgePointsGained += 1;
    addLogEntry(`${selected.member.name} discovered 1 knowledge point while gathering.`, 'success');
  }

  // Apply effects on hunger, thirst, and energy
  const effects = getResourceActionEffects(resourceType);
  selected.member.applyActionEffects(effects);

  addLogEntry(`${selected.member.name} gathered ${amountGathered} ${resourceType}.`, 'success');

  // Set the party member as busy for 1 hour
  gameState.busyUntil[selected.index] = gameState.hour + (gameState.day - 1) * 24 + 1;

  // Apply water purification effect if active
  if (resourceType === 'water' && gameState.waterPurificationActive) {
    const waterSaved = Math.floor(amountGathered * 0.2);
    amountGathered += waterSaved;
  }

  updateGameState();
  updateActionButtonsState();
  checkUpgradeAvailability();
}

/**
 * Determines the effects on hunger, thirst, and energy for each resource action.
 * @param {string} resourceType - The type of resource being gathered.
 * @returns {Object} An object containing the effects on hunger, thirst, and energy.
 */
function getResourceActionEffects(resourceType) {
  switch (resourceType) {
    case 'food':
      return { hunger: -1, thirst: -3, energy: -5 };
    case 'water':
      return { hunger: -3, thirst: -1, energy: -4 };
    case 'wood':
      return { hunger: -4, thirst: -4, energy: -6 };
    default:
      return { hunger: -2, thirst: -2, energy: -5 };
  }
}

/**
 * Performs the gather food action.
 */
export function gatherFood() {
  const efficiency = gameState.resourceEfficiency || 1;
  const minAmount = Math.floor((3 + (gameState.day / 10)) * efficiency);
  const maxAmount = Math.floor((8 + (gameState.day / 5)) * efficiency);
  performResourceAction('food', minAmount, maxAmount);
}

/**
 * Performs the collect water action.
 */
export function collectWater() {
  const efficiency = gameState.resourceEfficiency || 1;
  const minAmount = Math.floor((2 + (gameState.day / 10)) * efficiency);
  const maxAmount = Math.floor((6 + (gameState.day / 5)) * efficiency);
  performResourceAction('water', minAmount, maxAmount);
}

/**
 * Performs the chop wood action.
 */
export function chopWood() {
  const efficiency = gameState.resourceEfficiency || 1;
  const minAmount = Math.floor((1 + (gameState.day / 10)) * efficiency);
  const maxAmount = Math.floor((2 + (gameState.day / 5)) * efficiency);
  performResourceAction('wood', minAmount, maxAmount);
}

/**
 * Sets up event listeners for action buttons.
 */
export function setupActionListeners() {
  document.getElementById('gatherFoodBtn').addEventListener('click', gatherFood);
  document.getElementById('collectWaterBtn').addEventListener('click', collectWater);
  document.getElementById('chopWoodBtn').addEventListener('click', chopWood);
  updateActionButtonsState();
}

/**
 * Updates the state of action buttons based on available party members.
 */
export function updateActionButtonsState() {
  const isDisabled = !selectBestPartyMember();
  ['gatherFoodBtn', 'collectWaterBtn', 'chopWoodBtn'].forEach(btnId => {
    document.getElementById(btnId).disabled = isDisabled;
  });
}


================================================
FILE: javascript/automation.js
================================================
import { gameState } from './settings.js';
import { addLogEntry } from './log.js';
import { performAction, isBusy } from './party.js';

export function initializeAutomatedFeeding() {
  gameState.automations = gameState.automations || {};
  gameState.automations.feeding = true;
}

export function initializeWaterPurificationSystem() {
  gameState.automations = gameState.automations || {};
  gameState.automations.watering = true;
}

export function initializeComfortableSleepingQuarters() {
  gameState.automations = gameState.automations || {};
  gameState.automations.resting = true;
}

export function initializeFoodGatheringDrone() {
  gameState.automations = gameState.automations || {};
  gameState.automations.foodGathering = { active: true, lastGathered: gameState.hour + (gameState.day - 1) * 24 };
}

export function initializeWaterGatheringDrone() {
  gameState.automations = gameState.automations || {};
  gameState.automations.waterGathering = { active: true, lastGathered: gameState.hour + (gameState.day - 1) * 24 };
}

export function initializeWoodGatheringDrone() {
  gameState.automations = gameState.automations || {};
  gameState.automations.woodGathering = { active: true, lastGathered: gameState.hour + (gameState.day - 1) * 24 };
}

export function runAutomations() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;

  if (gameState.automations) {
    if (gameState.automations.feeding) {
      automatedFeeding();
    }
    if (gameState.automations.watering) {
      automatedWatering();
    }
    if (gameState.automations.resting) {
      automatedResting();
    }
    if (gameState.automations.foodGathering && gameState.automations.foodGathering.active) {
      automatedFoodGathering(currentTime);
    }
    if (gameState.automations.waterGathering && gameState.automations.waterGathering.active) {
      automatedWaterGathering(currentTime);
    }
    if (gameState.automations.woodGathering && gameState.automations.woodGathering.active) {
      automatedWoodGathering(currentTime);
    }
  }
}

function automatedFeeding() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  gameState.party.forEach((member, index) => {
    if (member.hunger <= 50 && gameState.food >= 5 && !isBusy(index, currentTime)) {
      performAction(index, 'eat');
      addLogEntry(`Automated Feeding System fed ${member.name}`);
    }
  });
}

function automatedWatering() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  gameState.party.forEach((member, index) => {
    if (member.thirst <= 50 && gameState.water >= 3 && !isBusy(index, currentTime)) {
      performAction(index, 'drink');
      addLogEntry(`Water Purification System provided water to ${member.name}`);
    }
  });
}

function automatedResting() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  gameState.party.forEach((member, index) => {
    if (member.energy <= 35 && !isBusy(index, currentTime)) {
      performAction(index, 'sleep');
      addLogEntry(`Comfortable Sleeping Quarters initiated rest for ${member.name}`);
    }
  });
}

function automatedFoodGathering(currentTime) {
  if (currentTime - gameState.automations.foodGathering.lastGathered >= 1) {
    const gatherAmount = Math.floor(Math.random() * 8) + 1; // Random amount between 1 and 8
    gameState.food += gatherAmount;
    gameState.totalResourcesGathered.food += gatherAmount;
    // addLogEntry(`Food Gathering Drone collected ${gatherAmount} food`);
    gameState.automations.foodGathering.lastGathered = currentTime;
  }
}

function automatedWaterGathering(currentTime) {
  if (currentTime - gameState.automations.waterGathering.lastGathered >= 1) {
    const gatherAmount = Math.floor(Math.random() * 5) + 1; // Random amount between 1 and 5
    gameState.water += gatherAmount;
    gameState.totalResourcesGathered.water += gatherAmount;
    // addLogEntry(`Water Gathering Drone collected ${gatherAmount} water`);
    gameState.automations.waterGathering.lastGathered = currentTime;
  }
}

function automatedWoodGathering(currentTime) {
  if (currentTime - gameState.automations.woodGathering.lastGathered >= 1) {
    const gatherAmount = Math.floor(Math.random() * 3) + 1; // Random amount between 1 and 3
    gameState.wood += gatherAmount;
    gameState.totalResourcesGathered.wood += gatherAmount;
    // addLogEntry(`Wood Gathering Drone collected ${gatherAmount} wood`);
    gameState.automations.woodGathering.lastGathered = currentTime;
  }
}


================================================
FILE: javascript/contentment.js
================================================
/**
 * Contentment System Module
 * This module handles the contentment system, which affects gameplay based on the overall
 * satisfaction of the party with their living conditions.
 */

import { gameState } from './settings.js';
import { addLogEntry } from './log.js';

// Contentment level thresholds and their descriptions
export const CONTENTMENT_LEVELS = {
  veryHigh: { min: 75, name: 'Very Happy', icon: 'laugh', color: 'green' },
  high: { min: 50, name: 'Happy', icon: 'smile', color: 'light-green' },
  medium: { min: 25, name: 'Concerned', icon: 'meh', color: 'yellow' },
  low: { min: 0, name: 'Unhappy', icon: 'frown', color: 'orange' },
  veryLow: { min: -Infinity, name: 'Miserable', icon: 'angry', color: 'red' }
};

// Effects applied at different contentment levels
export const CONTENTMENT_EFFECTS = {
  resourceEfficiency: {
    veryHigh: 0.15, // +15% resource gathering
    high: 0,        // No modifier
    medium: -0.03,  // -3% resource gathering
    low: -0.06,     // -6% resource gathering
    veryLow: -0.09  // -9% resource gathering
  },
  energyConsumption: {
    veryHigh: -0.1, // -10% energy consumption
    high: 0,        // No modifier
    medium: 0.05,   // +5% energy consumption
    low: 0.1,       // +10% energy consumption
    veryLow: 0.15   // +15% energy consumption
  },
  corruptionResistance: {
    veryHigh: 0.1,  // +10% corruption resistance
    high: 0,        // No modifier
    medium: -0.05,  // -5% corruption resistance
    low: -0.1,      // -10% corruption resistance
    veryLow: -0.15  // -15% corruption resistance
  }
};

/**
 * Initializes the contentment system
 */
export function initializeContentment() {
  // Add contentment properties to gameState if they don't exist
  if (gameState.contentmentLevel === undefined) {
    gameState.contentmentLevel = 50; // Start at neutral contentment
  }

  if (gameState.maxContentment === undefined) {
    gameState.maxContentment = 100;
  }

  if (gameState.contentmentEffects === undefined) {
    gameState.contentmentEffects = {
      resourceEfficiency: 0,
      energyConsumption: 0,
      corruptionResistance: 0
    };
  }

  // Initialize the UI
  updateContentmentDisplay();
}

/**
 * Increases contentment by the specified amount
 * @param {number} amount - The amount to increase contentment by
 * @param {string} reason - The reason for the contentment change (for logging)
 */
export function increaseContentment(amount, reason) {
  const previousLevel = getCurrentContentmentLevel();

  gameState.contentmentLevel = Math.min(
    gameState.contentmentLevel + amount,
    gameState.maxContentment
  );

  const newLevel = getCurrentContentmentLevel();

  // Log the change if significant
  if (amount >= 5) {
    addLogEntry(`Contentment increased${reason ? ` (${reason})` : ''}.`, 'success');
  }

  // Log when crossing a threshold
  if (previousLevel !== newLevel && newLevel.min > previousLevel.min) {
    addLogEntry(`The party's mood has improved to "${newLevel.name}"!`, 'success');
  }

  updateContentmentDisplay();
  updateContentmentEffects();
}

/**
 * Decreases contentment by the specified amount
 * @param {number} amount - The amount to decrease contentment by
 * @param {string} reason - The reason for the contentment change (for logging)
 */
export function decreaseContentment(amount, reason) {
  const previousLevel = getCurrentContentmentLevel();

  gameState.contentmentLevel = Math.max(
    gameState.contentmentLevel - amount,
    0
  );

  const newLevel = getCurrentContentmentLevel();

  // Log the change if significant
  if (amount >= 5) {
    addLogEntry(`Contentment decreased${reason ? ` (${reason})` : ''}.`, 'warning');
  }

  // Log when crossing a threshold
  if (previousLevel !== newLevel && newLevel.min < previousLevel.min) {
    addLogEntry(`The party's mood has worsened to "${newLevel.name}"!`, 'danger');
  }

  updateContentmentDisplay();
  updateContentmentEffects();
}

/**
 * Gets the current contentment level object based on the contentment value
 * @returns {Object} The contentment level object
 */
export function getCurrentContentmentLevel() {
  const contentment = gameState.contentmentLevel;

  if (contentment >= CONTENTMENT_LEVELS.veryHigh.min) return CONTENTMENT_LEVELS.veryHigh;
  if (contentment >= CONTENTMENT_LEVELS.high.min) return CONTENTMENT_LEVELS.high;
  if (contentment >= CONTENTMENT_LEVELS.medium.min) return CONTENTMENT_LEVELS.medium;
  if (contentment >= CONTENTMENT_LEVELS.low.min) return CONTENTMENT_LEVELS.low;
  return CONTENTMENT_LEVELS.veryLow;
}

/**
 * Updates the contentment effects based on the current contentment level
 */
export function updateContentmentEffects() {
  const level = getCurrentContentmentLevel();
  let levelKey;

  // Determine which level key to use
  for (const key in CONTENTMENT_LEVELS) {
    if (CONTENTMENT_LEVELS[key] === level) {
      levelKey = key;
      break;
    }
  }

  // Apply effects
  if (levelKey) {
    gameState.contentmentEffects = {
      resourceEfficiency: CONTENTMENT_EFFECTS.resourceEfficiency[levelKey],
      energyConsumption: CONTENTMENT_EFFECTS.energyConsumption[levelKey],
      corruptionResistance: CONTENTMENT_EFFECTS.corruptionResistance[levelKey]
    };
  }
}

/**
 * Updates the contentment display in the UI
 */
export function updateContentmentDisplay() {
  const contentmentDisplay = document.getElementById('contentment-display');
  if (!contentmentDisplay) return;

  const level = getCurrentContentmentLevel();

  // Update the icon and color
  const iconElement = contentmentDisplay.querySelector('i');
  if (iconElement) {
    iconElement.setAttribute('data-lucide', level.icon);

    // Remove all color classes
    iconElement.classList.remove('green', 'light-green', 'yellow', 'orange', 'red');

    // Add the appropriate color class
    iconElement.classList.add(level.color);
  }

  // Update the text
  const textElement = contentmentDisplay.querySelector('span');
  if (textElement) {
    textElement.textContent = level.name;
  }
}

/**
 * Checks and updates contentment based on resource levels and other factors
 * Should be called daily in the game loop
 */
export function checkContentmentEffects() {
  const { food, water, wood } = gameState;

  // Calculate resource percentages
  const foodPercentage = calculateResourcePercentage('food');
  const waterPercentage = calculateResourcePercentage('water');
  const woodPercentage = calculateResourcePercentage('wood');

  // Check if resources are low (below 10% of capacity)
  const lowResources = [];
  if (foodPercentage < 0.1) lowResources.push('food');
  if (waterPercentage < 0.1) lowResources.push('water');
  if (woodPercentage < 0.1) lowResources.push('wood');

  // Check if resources are high (above 50% of capacity)
  const highResources = [];
  if (foodPercentage > 0.5) highResources.push('food');
  if (waterPercentage > 0.5) highResources.push('water');
  if (woodPercentage > 0.5) highResources.push('wood');

  // Apply contentment changes
  if (lowResources.length > 0) {
    decreaseContentment(0.5 * lowResources.length, `low ${lowResources.join(', ')}`);
  }

  if (highResources.length > 0) {
    increaseContentment(0.5 * highResources.length, `abundant ${highResources.join(', ')}`);
  }
}

/**
 * Calculates the percentage of a resource relative to its maximum capacity
 * @param {string} resourceType - The type of resource to check
 * @returns {number} The percentage (0-1) of the resource
 */
function calculateResourcePercentage(resourceType) {
  // Default max values if not explicitly set
  const defaultMaxValues = {
    food: 100,
    water: 100,
    wood: 100
  };

  const currentAmount = gameState[resourceType] || 0;
  const maxKey = `max${resourceType.charAt(0).toUpperCase() + resourceType.slice(1)}`;
  const maxAmount = gameState[maxKey] || defaultMaxValues[resourceType] || 100;

  return currentAmount / maxAmount;
}

/**
 * Gets the contentment effects for use in other modules
 * @returns {Object} The current contentment effects
 */
export function getContentmentEffects() {
  return gameState.contentmentEffects;
} 


================================================
FILE: javascript/core.js
================================================
/*
  Core Module
  This module serves as the entry point for the game application.
  It initializes the game and sets up necessary components when the DOM is fully loaded.
*/

import { createLucideIcons } from './utils.js';
import { initializeGame } from './game.js';
import { initializeShortcuts } from './shortcuts.js';
import { initializeShortcutsModal } from './shortcuts-modal.js';
import './specializations.js'; // Import specializations module

/**
 * Event listener for DOMContentLoaded event.
 * This function is executed when the initial HTML document has been completely loaded and parsed.
 */
document.addEventListener('DOMContentLoaded', () => {
  // Log the start of initialization process
  console.log('DOM content loaded, starting initialization');

  // Create Lucide icons for the UI
  createLucideIcons();

  // Initialize the game
  initializeGame();

  // Initialize shortcuts and modal
  initializeShortcuts();
  initializeShortcutsModal();

  // Log successful initialization
  console.log('Game initialization complete');
});


================================================
FILE: javascript/farming.js
================================================
import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';

/**
 * Defines the types of crops and their properties.
 * @typedef {Object} CropType
 * @property {number} growthTime - Time in hours for the crop to grow
 * @property {number} waterNeeded - Amount of water needed to plant the crop
 * @property {number} yield - Amount of food yielded when harvested
 */

/**
 * @type {Object.<string, CropType>}
 */
const CROP_TYPES = {
  wheat: { growthTime: 24, waterNeeded: 5, yield: 20 },
  carrot: { growthTime: 48, waterNeeded: 10, yield: 50 },
  bean: { growthTime: 72, waterNeeded: 15, yield: 80 }
};

/**
 * Initializes the farming module in the game state.
 */
export function initializeFarming() {
  if (!gameState.farming) {
    gameState.farming = {
      grid: Array(5).fill().map(() => Array(5).fill(null)),
      maxCrops: 25,
      crops: CROP_TYPES,
      plantingCrop: 'wheat'
    };
  }
  updateFarmingUI();
}

/**
 * Plants a crop in the specified plot.
 * @param {number} row - The row index of the plot
 * @param {number} col - The column index of the plot
 */
export function plantCrop(row, col) {
  if (gameState.farming.grid[row][col] !== null) {
    return;
  }

  const cropType = gameState.farming.plantingCrop;
  const waterCost = CROP_TYPES[cropType].waterNeeded;

  if (gameState.water < waterCost) {
    addLogEntry(`Not enough water to plant ${cropType}. Need ${waterCost} water.`, 'error');
    return;
  }

  // Apply farming effects from upgrades and technologies
  const farmingEffects = applyAdvancedFarmingEffects();
  const baseGrowthTime = CROP_TYPES[cropType].growthTime;
  const adjustedGrowthTime = Math.floor(baseGrowthTime * farmingEffects.growthTimeReduction);

  gameState.water -= waterCost;
  gameState.farming.grid[row][col] = {
    type: cropType,
    plantedAt: gameState.hour + (gameState.day - 1) * 24,
    growthTime: adjustedGrowthTime,
    growthProgress: 0
  };

  addLogEntry(`Planted ${cropType} (requires ${adjustedGrowthTime} hours to grow)`, 'success');
  updateGameState();
  updateFarmingUI();
}

/**
 * Harvests a crop from the specified plot.
 * @param {number} row - The row index of the plot
 * @param {number} col - The column index of the plot
 */
export function harvestCrop(row, col) {
  const plot = gameState.farming.grid[row][col];
  if (!plot || plot.growthProgress < 1) {
    return;
  }

  const cropType = plot.type;
  const baseYield = CROP_TYPES[cropType].yield;

  // Apply farming effects from upgrades and technologies
  const farmingEffects = applyAdvancedFarmingEffects();
  const adjustedYield = Math.floor(baseYield * farmingEffects.yieldMultiplier);

  // Add the harvested food to the game state
  gameState.food += adjustedYield;
  gameState.totalResourcesGathered.food += adjustedYield;
  gameState.totalCropsHarvested += 1;

  // Clear the plot
  gameState.farming.grid[row][col] = null;

  addLogEntry(`Harvested ${cropType}: +${adjustedYield} food`, 'success');
  updateGameState();
  updateFarmingUI();
}

/**
 * Sets the current crop type for planting.
 * @param {string} cropType - The type of crop to set for planting
 */
export function setPlantingCrop(cropType) {
  gameState.farming.plantingCrop = cropType;
  updateFarmingUI();
}

/**
 * Updates the farming UI.
 */
export function updateFarmingUI() {
  const farmingModule = document.getElementById('farming-module');
  if (!farmingModule) return;

  farmingModule.innerHTML = `
    <h2><i data-lucide="sprout" class="icon-dark"></i> Farming</h2>
    <div class="crop-picker">
      ${Object.keys(CROP_TYPES).map(cropType => createCropButton(cropType)).join('')}
    </div>
    <div id="farming-grid">
      ${gameState.farming.grid.map((row, rowIndex) =>
    row.map((plot, colIndex) => createPlotElement(plot, rowIndex, colIndex)).join('')
  ).join('')}
    </div>
  `;

  createLucideIcons();
}

/**
 * Creates a button element for a crop type.
 * @param {string} cropType - The type of crop
 * @returns {string} HTML string for the crop button
 */
function createCropButton(cropType) {
  return `
    <button onclick="window.setPlantingCrop('${cropType}')" class="${gameState.farming.plantingCrop === cropType ? 'active' : ''}">
      <i data-lucide="${getCropIcon(cropType)}" class="icon ${getCropColor(cropType)}"></i>
      ${cropType} [${CROP_TYPES[cropType].waterNeeded} <i data-lucide="droplet" class="icon blue"></i>]
    </button>
  `;
}

/**
 * Creates an HTML element for a plot.
 * @param {Object|null} plot - The plot object or null if empty
 * @param {number} row - The row index of the plot
 * @param {number} col - The column index of the plot
 * @returns {string} HTML string for the plot element
 */
function createPlotElement(plot, row, col) {
  if (!plot) {
    return `<div class="plot-cell empty-plot" onclick="window.plantCrop(${row}, ${col})"></div>`;
  }

  const now = gameState.hour + (gameState.day - 1) * 24;
  // Use the plot's growthTime which has already been adjusted for advanced farming effects
  const growthProgress = (now - plot.plantedAt) / plot.growthTime;

  // Store the growth progress in the plot object
  plot.growthProgress = Math.min(growthProgress, 1);

  const isReady = plot.growthProgress >= 1;
  const progressPercent = Math.floor(plot.growthProgress * 100);

  // Determine growth class based on progress
  let growthClass = 'just-planted';
  if (isReady) {
    growthClass = 'ready-to-harvest';
  } else if (progressPercent >= 75) {
    growthClass = 'almost-ready';
  } else if (progressPercent >= 50) {
    growthClass = 'half-grown';
  } else if (progressPercent >= 25) {
    growthClass = 'quarter-grown';
  }

  return `
    <div class="plot-cell ${growthClass}"
         onclick="${isReady ? `window.harvestCrop(${row}, ${col})` : ''}"
         title="${plot.type}: ${progressPercent}% grown">
      <i data-lucide="${getCropIcon(plot.type)}" class="icon ${getCropColor(plot.type)}"></i>
      ${!isReady ? `<div class="growth-progress">${progressPercent}%</div>` : ''}
    </div>
  `;
}

/**
 * Gets the icon name for a crop type.
 * @param {string} cropType - The type of crop
 * @returns {string} The icon name
 */
function getCropIcon(cropType) {
  const icons = {
    wheat: 'wheat',
    carrot: 'carrot',
    bean: 'bean'
  };
  return icons[cropType] || 'sprout';
}

/**
 * Gets the color class for a crop type.
 * @param {string} cropType - The type of crop
 * @returns {string} The color class
 */
function getCropColor(cropType) {
  const colors = {
    wheat: 'light-yellow',
    carrot: 'dark-yellow',
    bean: 'dark-red'
  };
  return colors[cropType] || 'green';
}

/**
 * Applies the effects of the Advanced Farming upgrade and technology.
 * @returns {Object} The modified crop properties
 */
export function applyAdvancedFarmingEffects() {
  const hasAdvancedFarmingUpgrade = gameState.upgrades.advancedFarming;
  const hasAdvancedFarmingTech = gameState.technologies?.advancedFarming?.researched;

  let yieldMultiplier = 1;
  let growthTimeReduction = 1;

  // Apply upgrade effects
  if (hasAdvancedFarmingUpgrade) {
    yieldMultiplier *= 1.5; // 50% more yield
    growthTimeReduction *= 0.75; // 25% less growth time
  }

  // Apply technology effects
  if (hasAdvancedFarmingTech) {
    yieldMultiplier *= 1.5; // Additional 50% more yield
    growthTimeReduction *= 0.75; // Additional 25% less growth time
  }

  return {
    yieldMultiplier,
    growthTimeReduction
  };
}

// Expose functions to the global scope for onclick events
window.setPlantingCrop = setPlantingCrop;
window.plantCrop = plantCrop;
window.harvestCrop = harvestCrop;


================================================
FILE: javascript/game.js
================================================
/*
  Game Module
  This module handles core game functionality including initialization,
  difficulty selection, game controls, and state management.
*/

import { createLucideIcons, initializeCollapsibles } from './utils.js';
import { addLogEntry, clearLog, updateLogUI } from './log.js';
import { startTime, togglePause as toggleTimePause, resetTime, stopTime, updateTimeDisplay } from './time.js';
import { saveGameState, loadGameState, clearGameState } from './storage.js';
import { gameState, UPGRADES, resetGameState, STARTING_RESOURCES } from './settings.js';
import { initializeParty, updatePartyStats, updatePartyDisplay, performAction, PartyMember, checkPartyStatus } from './party.js';
import { setupActionListeners, updateActionButtonsState } from './actions.js';
import { initializeUpgrades, checkUpgradeAvailability, updateUpgradesUI, applyUpgradeEffects } from './upgrades.js';
import { unlockSecondaryModule } from './upgrades.js';
import { initializeFarming, updateFarmingUI } from './farming.js';
import { initializeWell, generateWellWater } from './well.js';
import { initializeHunting } from './hunting.js';
import { initializeLumberMill, updateLumberMill } from './lumbermill.js';
import { initializeAchievements, checkAchievements, ACHIEVEMENTS, updateAchievementsUI } from './achievements.js';
import { initializeWatchtower, checkRescueMission, updateWatchtowerUI } from './watchtower.js';
import { checkForRandomEvent, initializeRandomEvents } from './randomevents.js';
import { checkTutorials, initializeTutorials, saveTutorialState } from './tutorial.js';
import { runAutomations } from './automation.js';
import { applyMedicalTentEffects } from './medicaltent.js';
import { initializeContentment, checkContentmentEffects, updateContentmentDisplay, getContentmentEffects } from './contentment.js';
import { getKnowledgeGeneration } from './specializations.js';
import { initializeTechnologies, updateResearchProgress, showTechnologyModule, updateTechnologiesUI } from './technologies.js';

// Debug mode flag
let isDebugMode = false;

/**
 * Enables debug mode, unlocking all upgrades and setting resources to 1000.
 */
function enableDebugMode() {
  if (isDebugMode) return;
  console.log('Debug mode enabled');
  isDebugMode = true;
  gameState.food = 1000;
  gameState.water = 1000;
  gameState.wood = 1000;
  gameState.knowledgePoints = 1000;

  for (const upgradeId in UPGRADES) {
    gameState.upgrades[upgradeId] = true;
    UPGRADES[upgradeId].available = false;
    applyUpgradeEffects(upgradeId);
  }

  updateResourceDisplay();
  updateUpgradesUI();
  initializeUnlockedModules();
  addLogEntry('Debug mode enabled: All upgrades unlocked and resources set to 1000', 'success');
}

// Expose enableDebugMode to the global scope
window.enableDebugMode = enableDebugMode;

/**
 * Initializes the game by setting up event listeners and loading game state.
 */
export function initializeGame() {
  console.log('Initializing game...');

  // Add global click listener to resume game ticks when clicking outside dropdown
  document.addEventListener('click', (event) => {
    // If we're clicking anywhere that's not a select element or its option
    if (!event.target.closest('select')) {
      // Import the function dynamically to avoid circular dependencies
      import('./time.js').then(timeModule => {
        timeModule.pauseForUIInteraction(false);
      });
    }
  });

  setupDifficultySelection();
  setupGameControls();
  setupPartyActions();
  setupActionListeners();

  const loadedState = loadGame();
  if (loadedState === 'incompatible') {
    alert('Your saved game is incompatible with the current version. The game will be reset. There is no mercy in the apocalypse.');
    resetGame();
  } else if (loadedState) {
    showGameScreen();
    updateResourceDisplay();
    updatePartyDisplay();
    updateTimeDisplay();
    updateLogUI();
    initializeUpgrades();
    initializeTechnologies();
    startTime();

    // Check if there's a pending research to complete after loading
    if (gameState.completePendingResearch) {
      import('./technologies.js').then(techModule => {
        techModule.completeResearch(gameState.completePendingResearch);
        delete gameState.completePendingResearch;
      });
    }
  }

  updateStartScreenResources();
  initializeUpgrades();
  initializeAchievements();
  initializeUnlockedModules();
  initializeCollapsibles();
  initializeWatchtower();
  initializeRandomEvents();
  initializeTutorials();
  initializeContentment();

  // Check for debug mode
  if (window.location.hash === '#debug') {
    enableDebugMode();
  }

  console.log('Game initialization complete');
}

/**
 * Starts the game with the selected difficulty and sets initial resources.
 * @param {string} difficulty - The selected game difficulty.
 */
function startGame(difficulty) {
  console.log(`Starting game with ${difficulty} difficulty`);
  gameState.difficulty = difficulty;

  // Set initial resources based on difficulty
  if (STARTING_RESOURCES[difficulty]) {
    Object.assign(gameState, STARTING_RESOURCES[difficulty]);
  } else {
    console.error('Invalid difficulty selected');
    return;
  }

  initializeParty();
  initializeRandomEvents();
  showGameScreen();
  updateResourceDisplay();
  updatePartyDisplay();
  startTime();
  saveGameState(gameState);
  addLogEntry(`Game started with ${difficulty} difficulty`, 'success');
}

/**
 * Sets up event listeners for difficulty selection buttons.
 */
function setupDifficultySelection() {
  const difficultyButtons = document.querySelectorAll('#game_start_screen button[data-difficulty]');
  difficultyButtons.forEach(button => {
    button.addEventListener('click', () => startGame(button.dataset.difficulty));
  });
}

/**
 * Sets up event listeners for game control buttons (pause and reset).
 */
function setupGameControls() {
  const pauseButton = document.getElementById('pause-game');
  const resetButton = document.getElementById('reset-game');

  pauseButton?.addEventListener('click', togglePause);
  resetButton?.addEventListener('click', resetGame);
}

/**
 * Toggles the game pause state, updating UI elements accordingly.
 */
function togglePause() {
  const pauseButton = document.getElementById('pause-game');
  const pauseIcon = pauseButton.querySelector('.icon');
  const timeDisplayElement = document.querySelector('.time-display');
  const isPaused = pauseIcon.getAttribute('data-lucide') === 'pause';

  pauseIcon.setAttribute('data-lucide', isPaused ? 'play' : 'pause');
  createLucideIcons();
  timeDisplayElement.classList.toggle('paused', isPaused);

  console.log(`Game ${isPaused ? 'paused' : 'resumed'}`);
  toggleTimePause();
}

/**
 * Resets the game to its initial state and returns to the start screen.
 */
function resetGame() {
  if (confirm("Are you sure you want to reset the game? All progress will be lost.")) {
    console.log('Game reset');
    stopTime();
    resetTime();
    clearGameState();
    resetGameState();
    clearLog();
    showStartScreen();
    resetPauseButton();
    initializeHunting();
    initializeAchievements();
    updateAchievementsUI();
    updateStartScreenResources();
  }
}

/**
 * Updates the game state, including party stats and resource display.
 */
export function updateGameState() {
  // Check if the game is over
  if (checkPartyStatus()) {
    gameOver();
    return;
  }

  // Update party stats
  updatePartyStats();
  updatePartyDisplay();

  // Update resource display
  updateResourceDisplay();

  // Check for random events
  checkForRandomEvent();

  // Check for achievements
  checkAchievements();
  updateAchievementsUI();

  // Check for tutorials
  checkTutorials();

  // Check for rescue missions
  checkRescueMission();
  updateWatchtowerUI();

  // Update farming
  if (gameState.upgrades.farming) {
    updateFarmingUI();
  }

  // Generate well water
  if (gameState.upgrades.well) {
    generateWellWater();
  }

  // Update lumber mill
  if (gameState.upgrades.lumberMill) {
    updateLumberMill();
  }

  // Apply medical tent effects
  if (gameState.upgrades.medicalTent) {
    applyMedicalTentEffects();
  }

  // Run automations
  runAutomations();

  // Generate knowledge from researchers
  generateKnowledgeFromResearchers();

  // Check contentment effects
  checkContentmentEffects();
  updateContentmentDisplay();

  // Update research progress
  updateResearchProgress();

  // Update technologies UI if there's active research
  if (gameState.activeResearch) {
    updateTechnologiesUI();
  }

  // Check if technology module should be shown
  checkTechnologyModuleAvailability();

  // Update action buttons state
  updateActionButtonsState();

  // Save game state
  saveGameState();
}

/**
 * Generates knowledge points from party members with researcher specialization
 */
function generateKnowledgeFromResearchers() {
  if (!gameState.party) return;

  let totalKnowledgeGeneration = 0;

  gameState.party.forEach(member => {
    if (member.specialization === 'researcher' && !member.isDead) {
      const knowledgeGeneration = getKnowledgeGeneration(member);
      totalKnowledgeGeneration += knowledgeGeneration;
    }
  });

  if (totalKnowledgeGeneration > 0) {
    gameState.knowledgePoints += totalKnowledgeGeneration;
    gameState.totalKnowledgePointsGained += totalKnowledgeGeneration;
  }
}

/**
 * Checks if the technology module should be shown based on game progress
 */
function checkTechnologyModuleAvailability() {
  // Show technology module after day 10 or when player has at least 5 knowledge points
  const shouldShowTechModule = gameState.day >= 10 || gameState.knowledgePoints >= 5;

  // Check if technology module exists in the DOM
  const techModule = document.getElementById('technology-module');

  if (shouldShowTechModule && techModule) {
    // If the module is still a mystery, show it
    if (techModule.classList.contains('mystery')) {
      showTechnologyModule(true);
      addLogEntry('You have gained enough knowledge to unlock the Technology research system!', 'success');
    }
  }
}

/**
 * Loads a saved game state if available.
 */
function loadGame() {
  const savedState = loadGameState();
  if (savedState && savedState !== 'incompatible') {
    Object.assign(gameState, savedState);
    reconstructPartyMembers();
    return true;
  }
  return savedState;
}

/**
 * Reconstructs PartyMember objects from saved state.
 */
function reconstructPartyMembers() {
  gameState.party = gameState.party.map(member => {
    const reconstructedMember = new PartyMember(member.name);
    return Object.assign(reconstructedMember, member);
  });
}

/**
 * Updates the displayed resource values in the UI.
 */
function updateResourceDisplay() {
  const resourceElements = document.querySelectorAll('.resources .resource span');
  ['food', 'water', 'wood', 'knowledgePoints'].forEach((resource, index) => {
    resourceElements[index].textContent = gameState[resource];
  });

  // Update contentment display if it exists
  const contentmentDisplay = document.getElementById('contentment-display');
  if (contentmentDisplay) {
    updateContentmentDisplay();
  }
}

/**
 * Updates the displayed resource values in the start screen based on STARTING_RESOURCES.
 */
function updateStartScreenResources() {
  const difficultyButtons = document.querySelectorAll('#game_start_screen button[data-difficulty]');

  difficultyButtons.forEach(button => {
    const difficulty = button.dataset.difficulty;
    const resources = STARTING_RESOURCES[difficulty];

    if (resources) {
      ['food', 'water', 'wood'].forEach(resource => {
        const span = button.querySelector(`.${resource} b`);
        if (span) span.textContent = `${resources[resource]} `;
      });
    }
  });
}

/**
 * Sets up event listeners for party action buttons.
 */
function setupPartyActions() {
  const partyContainer = document.getElementById('party-display');
  if (!partyContainer) {
    console.error('Party container not found');
    return;
  }

  partyContainer.addEventListener('click', handlePartyAction);
  console.log('Party actions setup complete');
}

/**
 * Handles click events on party action buttons.
 * @param {Event} event - The click event.
 */
function handlePartyAction(event) {
  const button = event.target.closest('button');
  if (button && !button.disabled) {
    const action = button.dataset.action;
    const personIndex = parseInt(button.dataset.person, 10);
    try {
      performAction(personIndex, action);
    } catch (error) {
      console.error('Error performing action:', error);
    }
  }
}

/**
 * Displays the game over screen with final stats.
 */
export function gameOver() {
  stopTime();
  showGameOverScreen();
  addLogEntry('Game Over! Everyone has died.', 'error');
}

function showGameOverScreen() {
  document.getElementById('game_start_screen').classList.add('hidden');
  document.getElementById('game_screen').classList.add('hidden');
  document.getElementById('game_over_screen').classList.remove('hidden');

  const gameOverContent = document.getElementById('game_over_content');
  const timePlayed = (gameState.day - 1) * 24 + gameState.hour;
  const hoursPlayed = Math.floor(timePlayed);
  const daysPlayed = Math.floor(hoursPlayed / 24);

  // Get achieved achievements
  const achievedAchievements = ACHIEVEMENTS.filter(achievement => gameState.achievements[achievement.id]);

  gameOverContent.innerHTML = `
    <div class="splash_screen">
      <div class="splash_header">
        <i data-lucide="skull" class="icon-large"></i>
        <div>
          <h1>Society Failed</h1>
        </div>
      </div>
      <div id="game_stats">
        <h2>
          <b>Time Survived</b>
          <span class="time">${daysPlayed} days, ${hoursPlayed % 24} hours</span>
        </h2>
        <div class="numbers">
          <p>Resources</p>
          <div class="resource-list">
            <div class="resource"><i data-lucide="beef" class="icon dark-yellow"></i><span>${Math.floor(gameState.totalResourcesGathered.food)}</span></div>
            <div class="resource"><i data-lucide="droplet" class="icon blue"></i><span>${Math.floor(gameState.totalResourcesGathered.water)}</span></div>
            <div class="resource"><i data-lucide="tree-pine" class="icon green"></i><span>${Math.floor(gameState.totalResourcesGathered.wood)}</span></div>
            <div class="resource"><i data-lucide="book" class="icon magenta"></i><span>${Math.floor(gameState.totalKnowledgePointsGained)}</span></div>
          </div>
        </div>
        <div class="achievements">
          <div class="achievement-list">
            ${achievedAchievements.map(achievement => `
              <div class="achievement-item">
                <div class="achievement-name">${achievement.name}</div>
                <div class="achievement-description">${achievement.description}</div>
              </div>
            `).join('')}
          </div>
          ${achievedAchievements.length === 0 ? '<p class="no-achievements">No achievements unlocked</p>' : ''}
        </div>
      </div>
      <button id="restart-game">Restart Game</button>
    </div>
  `;

  document.getElementById('restart-game').addEventListener('click', resetGame);
  createLucideIcons();
}

/**
 * Shows the game screen and hides others.
 */
function showGameScreen() {
  document.getElementById('game_start_screen').classList.add('hidden');
  document.getElementById('game_screen').classList.remove('hidden');
}

/**
 * Shows the start screen and hides others.
 */
function showStartScreen() {
  document.getElementById('game_screen').classList.add('hidden');
  document.getElementById('game_over_screen').classList.add('hidden');
  document.getElementById('game_start_screen').classList.remove('hidden');
}

/**
 * Resets the pause button icon to 'pause'.
 */
function resetPauseButton() {
  const pauseButton = document.getElementById('pause-game');
  const pauseIcon = pauseButton.querySelector('.icon');
  pauseIcon.setAttribute('data-lucide', 'pause');
  createLucideIcons();
}

/**
 * Initializes all unlocked modules based on the game state
 */
function initializeUnlockedModules() {
  if (gameState.upgrades.farming) {
    unlockSecondaryModule('farming-module');
    initializeFarming();
  }

  if (gameState.upgrades.well) {
    unlockSecondaryModule('well-module');
    initializeWell();
  }

  if (gameState.upgrades.huntingLodge) {
    unlockSecondaryModule('hunting-module');
    initializeHunting();
  }

  if (gameState.upgrades.lumberMill) {
    unlockSecondaryModule('lumber-mill-module');
    initializeLumberMill();
  }

  if (gameState.upgrades.watchtower) {
    unlockSecondaryModule('watchtower-module');
    initializeWatchtower();
  }

  // Initialize technology module if conditions are met
  if (gameState.day >= 10 || gameState.knowledgePoints >= 5) {
    // Add technology module to secondary modules if it doesn't exist
    if (!document.getElementById('technology-module')) {
      const secondaryModules = document.getElementById('secondary-modules');
      if (secondaryModules) {
        const techModule = document.createElement('section');
        techModule.id = 'technology-module';
        techModule.className = 'mystery';
        techModule.innerHTML = `
          <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
          <div class="title">Ancient Knowledge</div>
          <div class="description">What secrets await those who seek to understand?</div>
        `;
        secondaryModules.appendChild(techModule);
        createLucideIcons();
      }
    }

    showTechnologyModule(true);
    initializeTechnologies();
  }
}


================================================
FILE: javascript/hunting.js
================================================
import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';

/**
 * Defines the types of animals and their properties.
 * @typedef {Object} AnimalType
 * @property {number} foodYield - Amount of food yielded when hunted
 * @property {string} icon - Lucide icon name for the animal
 */

/**
 * @type {Object.<string, AnimalType>}
 */
const ANIMAL_TYPES = {
  rabbit: { foodYield: 5, icon: 'rabbit' },
  bird: { foodYield: 3, icon: 'bird' },
  rat: { foodYield: 2, icon: 'rat' },
  snail: { foodYield: 1, icon: 'snail' },
  squirrel: { foodYield: 4, icon: 'squirrel' },
  turtle: { foodYield: 6, icon: 'turtle' }
};

/**
 * Initializes the hunting module.
 */
export function initializeHunting() {
  if (!gameState.hunting) {
    gameState.hunting = { animals: [] };
  }
  resetHuntingArea();
  addLogEntry('Hunting Lodge is now operational.');
}

/**
 * Resets the hunting area with new animals and movement interval.
 */
function resetHuntingArea() {
  gameState.hunting.animals = generateAnimals();
  clearInterval(gameState.moveInterval);
  gameState.moveInterval = setInterval(moveAnimals, 500);
  updateHuntingUI();
}

/**
 * Generates a random set of animals.
 * @returns {Array} Array of animal objects.
 */
function generateAnimals() {
  const numAnimals = Math.floor(Math.random() * 3) + 1;
  const animalTypes = Object.keys(ANIMAL_TYPES);
  return Array.from({ length: numAnimals }, () => ({
    type: animalTypes[Math.floor(Math.random() * animalTypes.length)],
    x: Math.random() * 100,
    y: Math.random() * 100
  }));
}

/**
 * Moves the animals randomly within the hunting area.
 */
function moveAnimals() {
  gameState.hunting.animals = gameState.hunting.animals.map(animal => ({
    ...animal,
    x: Math.max(0, Math.min(100, animal.x + (Math.random() - 0.5) * 10)),
    y: Math.max(0, Math.min(100, animal.y + (Math.random() - 0.5) * 10))
  }));
  updateHuntingUI();
}

/**
 * Updates the hunting UI.
 */
function updateHuntingUI() {
  const huntingModule = document.getElementById('hunting-module');
  if (!huntingModule) return;

  huntingModule.classList.toggle('hidden', !gameState.upgrades.huntingLodge);

  if (gameState.upgrades.huntingLodge) {
    huntingModule.innerHTML = `
      <h2><i data-lucide="target" class="icon-dark"></i> Hunting Lodge</h2>
      <div id="hunting-area">
        ${gameState.hunting.animals.map(renderAnimal).join('')}
      </div>
    `;
    createLucideIcons();
  }
}

/**
 * Renders an individual animal for the hunting UI.
 * @param {Object} animal - The animal object to render
 * @returns {string} HTML string for the animal
 */
function renderAnimal(animal) {
  return `
    <div class="wildlife" style="left: ${animal.x}%; top: ${animal.y}%;" onclick="window.shootAnimal(${animal.x}, ${animal.y})">
      <i data-lucide="${ANIMAL_TYPES[animal.type].icon}" class="icon-dark"></i>
    </div>
  `;
}

/**
 * Shoots an animal at the given coordinates.
 * @param {number} x - The x-coordinate of the animal.
 * @param {number} y - The y-coordinate of the animal.
 */
export function shootAnimal(x, y) {
  const animalIndex = gameState.hunting.animals.findIndex(animal =>
    Math.abs(animal.x - x) < 5 && Math.abs(animal.y - y) < 5
  );

  if (animalIndex !== -1) {
    const animal = gameState.hunting.animals[animalIndex];
    const foodGained = ANIMAL_TYPES[animal.type].foodYield;
    gameState.food += foodGained;
    gameState.totalAnimalsHunted = (gameState.totalAnimalsHunted || 0) + 1;
    addLogEntry(`Shot a ${animal.type}! Gained ${foodGained} food.`);
    gameState.hunting.animals.splice(animalIndex, 1);

    // Reset hunting area if no animals remain
    if (gameState.hunting.animals.length === 0) {
      resetHuntingArea();
    } else {
      updateHuntingUI();
    }

    updateGameState();
  }
}

// Expose function to the global scope for onclick events
window.shootAnimal = shootAnimal;


================================================
FILE: javascript/log.js
================================================
import { gameState } from './settings.js';

/**
 * Log Module
 * Handles game log functionality including adding entries, updating UI, and initialization.
 */

const MAX_LOG_ENTRIES = 100;

/**
 * Adds a new log entry to the game state and updates the UI.
 * @param {string} message - The message to be logged.
 * @param {string} [type='info'] - The type of log entry (info, warning, error, success, whisper).
 */
export function addLogEntry(message, type = 'info') {
  const entryData = {
    message,
    type,
    day: gameState.day,
    hour: gameState.hour
  };

  // Initialize logEntries if it doesn't exist
  gameState.logEntries = gameState.logEntries || [];

  // Add new entry to the beginning of the array
  gameState.logEntries.unshift(entryData);

  // Limit the number of log entries
  if (gameState.logEntries.length > MAX_LOG_ENTRIES) {
    gameState.logEntries.pop();
  }

  updateLogUI();
}

/**
 * Updates the log UI with the current log entries.
 */
export function updateLogUI() {
  const logContent = document.getElementById('log-content');
  if (!logContent) return;

  logContent.innerHTML = gameState.logEntries.map(entry =>
    `<div class="log-entry ${entry.type}">
      <b>${entry.day}.${entry.hour}</b>
      <span>${entry.message}</span>
    </div>`
  ).join('');
}

/**
 * Clears all log entries and updates the UI.
 */
export function clearLog() {
  gameState.logEntries = [];
  updateLogUI();
}


================================================
FILE: javascript/lumbermill.js
================================================
import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';

/**
 * Lumber Mill Module
 * This module manages the lumber mill functionality in the game.
 */

/**
 * Initializes the lumber mill in the game state.
 * Sets up initial trees if not already present.
 */
export function initializeLumberMill() {
  if (!gameState.lumberMill) {
    gameState.lumberMill = {
      trees: [],
      maxTrees: 5,
      baseGrowthTime: 24,
      growthTimeVariance: 12,
      baseHarvestAmount: 10,
      harvestAmountVariance: 5
    };
  }

  if (!gameState.lumberMill.trees || gameState.lumberMill.trees.length === 0) {
    gameState.lumberMill.trees = Array(gameState.lumberMill.maxTrees).fill().map(createTree);
  }

  updateLumberMillUI();
}

/**
 * Creates a new tree object with randomized properties.
 * @returns {Object} A new tree object
 */
function createTree() {
  const { baseGrowthTime, growthTimeVariance, baseHarvestAmount, harvestAmountVariance } = gameState.lumberMill;
  return {
    growth: 0,
    growthTime: baseGrowthTime + (Math.random() * 2 - 1) * growthTimeVariance,
    harvestAmount: Math.round(baseHarvestAmount + (Math.random() * 2 - 1) * harvestAmountVariance)
  };
}

/**
 * Harvests a tree at the specified index.
 * @param {number} index - The index of the tree to harvest
 */
export function harvestTree(index) {
  const tree = gameState.lumberMill.trees[index];
  if (tree.growth >= 1) {
    gameState.wood += tree.harvestAmount;
    addLogEntry(`Harvested a tree from the Lumber Mill, gaining ${tree.harvestAmount} wood.`, 'success');

    // Reset the tree
    gameState.lumberMill.trees[index] = createTree();

    updateLumberMillUI();
    updateGameState();
  }
}

/**
 * Grows trees in the lumber mill and adds new trees if needed.
 */
export function growLumberMillTrees() {
  if (gameState.upgrades.lumberMill) {
    gameState.lumberMill.trees = gameState.lumberMill.trees.map(growTree);

    // Add new trees if needed
    while (gameState.lumberMill.trees.length < gameState.lumberMill.maxTrees) {
      gameState.lumberMill.trees.push(createTree());
    }

    // Trim excess trees
    gameState.lumberMill.trees = gameState.lumberMill.trees.slice(0, gameState.lumberMill.maxTrees);
    updateLumberMillUI();
  }
}

/**
 * Grows a single tree.
 * @param {Object} tree - The tree to grow
 * @returns {Object} The updated tree
 */
function growTree(tree) {
  return {
    ...tree,
    growth: Math.min(1, tree.growth + (1 / tree.growthTime))
  };
}

/**
 * Updates the lumber mill state.
 */
export function updateLumberMill() {
  if (gameState.upgrades.lumberMill) {
    gameState.lumberMill.trees = gameState.lumberMill.trees.map(growTree);
    updateLumberMillUI();
  }
}

/**
 * Updates the lumber mill UI.
 */
function updateLumberMillUI() {
  const lumberMillModule = document.getElementById('lumber-mill-module');
  if (!lumberMillModule) return;

  lumberMillModule.innerHTML = `
    <h2><i data-lucide="axe" class="icon-dark"></i> Lumber Mill</h2>
    <div id="lumber-mill-grid">
      ${gameState.lumberMill.trees.map(renderTreeCell).join('')}
    </div>
  `;

  createLucideIcons();
}

/**
 * Renders a single tree cell.
 * @param {Object} tree - The tree to render
 * @param {number} index - The index of the tree
 * @returns {string} HTML string for the tree cell
 */
function renderTreeCell(tree, index) {
  const isReadyToHarvest = tree.growth >= 1;
  return `
    <div class="tree-cell ${isReadyToHarvest ? 'ready-to-harvest' : ''}" 
         onclick="${isReadyToHarvest ? `window.harvestTree(${index})` : ''}">
      <i data-lucide="tree-pine" class="icon"></i>
      <div class="growth-indicator" style="height: ${tree.growth * 100}%"></div>
    </div>
  `;
}

// Expose functions to the global scope for onclick events
window.harvestTree = harvestTree;


================================================
FILE: javascript/medicaltent.js
================================================
import { gameState } from './settings.js';
import { addLogEntry } from './log.js';

export function initializeMedicalTent() {
  if (!gameState.medicalTent) {
    gameState.medicalTent = {
      active: true,
      healingRate: 1, // Health points restored per hour
      illnessReductionFactor: 0.5 // Reduces chance of illness by 50%
    };
  }
  addLogEntry('Medical Tent is now operational. It will slowly heal injured party members and reduce the chance of illness.');
}

export function applyMedicalTentEffects() {
  if (gameState.medicalTent && gameState.medicalTent.active) {
    gameState.party.forEach(member => {
      if (member.health < 100) {
        member.health = Math.min(100, member.health + gameState.medicalTent.healingRate);
      }
    });
  }
}

export function getIllnessChanceReduction() {
  return gameState.medicalTent && gameState.medicalTent.active ? gameState.medicalTent.illnessReductionFactor : 0;
}


================================================
FILE: javascript/party.js
================================================
/*
  Party Module
  This module handles the creation and management of party members in the game.
  It includes functions for initializing the party, updating party stats,
  displaying party information, and performing actions for party members.
*/

import { gameState } from './settings.js';
import { gameOver, updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { getContentmentEffects } from './contentment.js';
import { specializationTypes, applySpecializationEffects } from './specializations.js';
import { pauseForUIInteraction } from './time.js';

// Move this outside the class to be accessible by all instances
const usedNames = new Set();

/**
 * Represents a party member in the game.
 */
export class PartyMember {
  /**
   * Creates a new party member.
   */
  constructor() {
    this.name = this.generateName();
    this.health = 100;
    this.hunger = 100;
    this.thirst = 100;
    this.energy = 100;
    this.specialization = null;
    this.traits = {
      hungerRate: Math.random() * 0.5 + 0.5,
      thirstRate: Math.random() * 0.75 + 0.75,
      energyRate: Math.random() * 0.4 + 0.3,
      maxEnergy: 100,
      energyRecoveryRate: Math.random() * 1.5 + 1
    };
  }

  generateName() {
    return getUniqueRandomName(usedNames);
  }

  /**
   * Sets the specialization for this party member.
   * @param {string} specializationType - The type of specialization to set.
   */
  setSpecialization(specializationType) {
    if (specializationTypes[specializationType]) {
      this.specialization = specializationType;
      addLogEntry(`${this.name} is now a ${specializationTypes[specializationType].name}.`, 'success');
      return true;
    }
    return false;
  }

  /**
   * Updates the party member's stats based on their traits.
   */
  updateStats() {
    if (this.isDead) {
      this.hunger = 0;
      this.thirst = 0;
      this.energy = 0;
      return;
    }

    // Apply contentment effects to energy consumption
    const contentmentEffects = getContentmentEffects();
    const energyConsumptionModifier = 1 + (contentmentEffects.energyConsumption || 0);

    // Decrease hunger, thirst, and energy
    this.hunger = Math.max(0, this.hunger - this.traits.hungerRate);
    this.thirst = Math.max(0, this.thirst - this.traits.thirstRate);

    // Apply contentment modifier to energy consumption
    const energyDecrease = this.traits.energyRate * energyConsumptionModifier;
    this.energy = Math.max(0, Math.min(100, this.energy - energyDecrease));

    // Calculate health loss
    const healthLoss = (this.hunger <= 0 || this.thirst <= 0 || this.energy <= 0) ? 2 : 0;
    this.health = Math.max(0, this.health - healthLoss);

    // Additional health loss for each stat at 0
    if (this.hunger <= 0) this.health = Math.max(0, this.health - 1);
    if (this.thirst <= 0) this.health = Math.max(0, this.health - 1);
    if (this.energy <= 0) this.health = Math.max(0, this.health - 1);

    // Check if person has died
    if (this.health <= 0) {
      this.isDead = true;
      this.health = 0;
      this.hunger = 0;
      this.thirst = 0;
      this.energy = 0;
    }

    // Recover health if all stats are above 50%
    if (this.hunger > 50 && this.thirst > 50 && this.energy > 50 && this.health < 100) {
      this.health = Math.min(100, this.health + 0.1);
    }

    // Apply specialization effects
    applySpecializationEffects(this);
  }

  applyActionEffects(effects) {
    this.hunger = Math.max(0, Math.min(100, this.hunger + effects.hunger));
    this.thirst = Math.max(0, Math.min(100, this.thirst + effects.thirst));
    this.energy = Math.max(0, Math.min(100, this.energy + effects.energy)); // Ensure energy doesn't exceed 100

    // Check if the action caused any critical conditions
    if (this.hunger <= 0 || this.thirst <= 0 || this.energy <= 0) {
      this.health -= 5; // Lose health if any stat reaches 0
      if (this.health <= 0) {
        this.isDead = true;
        this.health = 0;
        addLogEntry(`${this.name} has died due to exhaustion.`, 'error');
      }
    }
  }
}

// Array of possible names for party members
const possibleNames = [
  "Alex", "Sam", "Jordan", "Taylor", "Morgan", "Casey", "Riley", "Avery",
  "Quinn", "Skyler", "Charlie", "Frankie", "Finley", "Sage", "Remy",
  "Addison", "Blake", "Cameron", "Dakota", "Emerson", "Finley",
  "Harper", "Jaden", "Kennedy", "London", "Micah", "Noel",
  "Oakley", "Parker", "Quinn", "Reese", "Sawyer", "Tatum", "Uriah",
  "Val", "Winter", "Xen", "Yael", "Zion", "Arden", "Bellamy", "Corey",
  "Drew", "Ellis", "Fallon", "Greer", "Hadley", "Ira", "Jules",
  "Kai", "Lennon", "Marlowe", "Nova", "Onyx", "Phoenix", "River",
  "Shiloh", "Tate", "Unity", "Vesper", "Wren", "Xander", "Yara", "Zephyr"
];

/**
 * Gets a unique random name from the list of possible names.
 * @param {Set} usedNames - Set of already used names.
 * @returns {string} A unique random name.
 */
function getUniqueRandomName(usedNames) {
  let name;
  do {
    name = possibleNames[Math.floor(Math.random() * possibleNames.length)];
  } while (usedNames.has(name));
  usedNames.add(name);
  return name;
}

/**
 * Initializes the party with three members if it doesn't exist.
 */
export function initializeParty() {
  if (!gameState.party || gameState.party.length === 0) {
    const usedNames = new Set();
    gameState.party = Array.from({ length: 3 }, () => new PartyMember(getUniqueRandomName(usedNames)));
    gameState.busyUntil = Array(3).fill(0);
  }

  // Add document mousedown listener to detect clicks outside dropdown
  // Only add this once during initialization
  if (!window.dropdownListenerAdded) {
    document.addEventListener('mousedown', (event) => {
      if (!event.target.closest('.specialization-dropdown')) {
        window.isSpecDropdownOpen = false;
      }
    });
    window.dropdownListenerAdded = true;
  }
}

/**
 * Updates the stats of all party members based on current conditions.
 */
export function updatePartyStats() {
  if (!gameState.party) return;

  const currentTime = gameState.hour + (gameState.day - 1) * 24;

  // Check if it's a new day (hour 1)
  const isNewDay = gameState.hour === 1;

  gameState.party.forEach((member, index) => {
    if (member.isDead) return;

    // Apply medicinal herbs technology effect (5% health regeneration per day)
    if (isNewDay && gameState.technologies?.medicinalHerbs?.researched) {
      const healthRegen = Math.ceil(member.maxHealth * 0.05);
      member.health = Math.min(member.maxHealth, member.health + healthRegen);
    }

    const isResting = gameState.busyUntil[index] === -1;
    const isBusy = gameState.busyUntil[index] > currentTime;

    if (!isResting && !isBusy) {
      member.updateStats();
    } else if (isResting) {
      // Increased energy recovery rate (approximately 16.67% per hour)
      const energyRecoveryRate = member.traits.maxEnergy / 4;
      member.energy = Math.min(100, member.energy + energyRecoveryRate); // Ensure energy doesn't exceed 100

      // Slower hunger and thirst decrease while resting
      member.hunger = Math.max(0, member.hunger - member.traits.hungerRate * 0.2);
      member.thirst = Math.max(0, member.thirst - member.traits.thirstRate * 0.2);

      // Increased health recovery if hunger and thirst are above 50%
      if (member.hunger > 50 && member.thirst > 50 && member.health < 100) {
        member.health = Math.min(100, member.health + 1);
      }

      if (member.energy >= 100) {
        gameState.busyUntil[index] = currentTime;
        member.energy = 100;
      }
    }
    // If busy, do nothing (stats remain unchanged)
  });

  updatePartyDisplay();
  checkPartyStatus();
}

/**
 * Gets the appropriate CSS class for a progress bar based on its value.
 * @param {number} value - The current value of the stat.
 * @returns {string} The CSS class for the progress bar.
 */
function getProgressBarClass(value) {
  if (value > 66) return 'high';
  if (value > 33) return 'medium';
  return 'low';
}

/**
 * Updates the party display in the UI.
 */
export function updatePartyDisplay() {
  const partyContainer = document.getElementById('party-display');
  partyContainer.innerHTML = '';

  // Add a flag to track if a dropdown is open
  window.isSpecDropdownOpen = false;

  gameState.party.forEach((person, index) => {
    const personElement = document.createElement('div');
    personElement.className = 'person';
    const currentTime = gameState.hour + (gameState.day - 1) * 24;
    const isBusy = gameState.busyUntil[index] > currentTime;
    const isResting = gameState.busyUntil[index] === -1;
    const busyTimeLeft = isBusy ? gameState.busyUntil[index] - currentTime : 0;

    // Get specialization info if the person has one
    const specializationInfo = person.specialization ?
      specializationTypes[person.specialization] : null;

    // Check if specializations upgrade has been purchased
    const hasSpecializationsUpgrade = gameState.upgrades.specializations;

    personElement.innerHTML = `
      <div class="person-header">
        <h3><i data-lucide="person-standing" class="icon-gutter-grey"></i> ${person.name}</h3>
        <div class="busy-label ${person.isDead ? 'dead' : (isBusy ? 'busy' : (isResting ? 'resting' : 'idle'))}">${person.isDead ? 'DEAD' : (isBusy ? `BUSY [${busyTimeLeft}h]` : (isResting ? 'RESTING' : 'IDLE'))}</div>
      </div>
      ${hasSpecializationsUpgrade ? `
      <div class="specialization">
        <div class="specialization-select">
          <div class="specialization-left">
            <i data-lucide="${specializationInfo ? specializationTypes[person.specialization].icon : 'briefcase'}" class="icon specialization-icon"></i>
            <select data-person="${index}" class="specialization-dropdown" ${person.isDead || isBusy || isResting ? 'disabled' : ''}>
              <option value="">Select Specialization</option>
              ${Object.values(specializationTypes).map(spec => `
                <option value="${spec.id}" ${person.specialization === spec.id ? 'selected' : ''}>${spec.name}</option>
              `).join('')}
            </select>
          </div>
          <div class="specialization-description">
            ${specializationInfo ? specializationInfo.description : 'Choose a role for this party member'}
          </div>
        </div>
      </div>
      ` : ''}
      <div class="stats-container">
        <table class="stats">
          ${['health', 'hunger', 'thirst', 'energy'].map(stat => `
            <tr>
              <td>${stat.charAt(0).toUpperCase() + stat.slice(1)}</td>
              <td><div class="progress-bar"><div class="progress ${stat}-bar ${getProgressBarClass(person[stat])}" style="width: ${person[stat]}%;"></div></div></td>
              <td>${Math.floor(person[stat])}%</td>
            </tr>
          `).join('')}
        </table>
      </div>
      <div class="person-actions">
        <button data-action="eat" data-person="${index}" ${(person.isDead || isBusy || isResting || gameState.food < 5) ? 'disabled' : ''}>
          ${index === 0 ? '<span class="shortcut">u</span>' : index === 1 ? '<span class="shortcut">j</span>' : '<span class="shortcut">m</span>'}
          Eat <span>[5 <i data-lucide="beef" class="icon dark-yellow"></i>]</span>
        </button>
        <button data-action="drink" data-person="${index}" ${(person.isDead || isBusy || isResting || gameState.water < 3) ? 'disabled' : ''}>
          ${index === 0 ? '<span class="shortcut">i</span>' : index === 1 ? '<span class="shortcut">k</span>' : '<span class="shortcut">,</span>'}
          Drink <span>[3 <i data-lucide="droplet" class="icon blue"></i>]</span>
        </button>
        <button data-action="sleep" data-person="${index}" ${(person.isDead || isBusy || isResting) ? 'disabled' : ''}>
          ${index === 0 ? '<span class="shortcut">o</span>' : index === 1 ? '<span class="shortcut">l</span>' : '<span class="shortcut">.</span>'}
          <i data-lucide="bed-single" class="icon magenta"></i> Rest
        </button>
      </div>
    `;
    partyContainer.appendChild(personElement);

    // Add event listeners for specialization dropdown
    if (hasSpecializationsUpgrade && !person.isDead && !isBusy && !isResting) {
      const specDropdown = personElement.querySelector('.specialization-dropdown');
      if (specDropdown) {
        // Pause game ticks when dropdown is focused
        specDropdown.addEventListener('mousedown', (event) => {
          window.isSpecDropdownOpen = true;
          pauseForUIInteraction(true);
        });

        specDropdown.addEventListener('focus', (event) => {
          window.isSpecDropdownOpen = true;
          pauseForUIInteraction(true);
        });

        // Resume game ticks when dropdown loses focus
        specDropdown.addEventListener('blur', (event) => {
          // Small delay to allow for selection to complete
          setTimeout(() => {
            if (!window.isSpecDropdownOpen) {
              pauseForUIInteraction(false);
            }
          }, 100);
        });

        specDropdown.addEventListener('change', (event) => {
          event.preventDefault();
          event.stopPropagation();
          const specType = event.target.value;
          const personIndex = parseInt(event.target.getAttribute('data-person'));
          if (specType !== undefined) {
            setPartyMemberSpecialization(personIndex, specType);
          }
          // Resume game ticks after selection is made
          window.isSpecDropdownOpen = false;
          pauseForUIInteraction(false);
        });
      }
    }
  });

  // Remove the document mousedown listener from here since we added it in initializeParty

  // Refresh Lucide icons
  if (typeof lucide !== 'undefined' && typeof lucide.createIcons === 'function') {
    lucide.createIcons();
  }
}

/**
 * Sets the specialization for a party member.
 * @param {number} personIndex - The index of the party member.
 * @param {string} specializationType - The type of specialization to set.
 */
export function setPartyMemberSpecialization(personIndex, specializationType) {
  const person = gameState.party[personIndex];
  if (!person || person.isDead) return;

  // If specializationType is empty, clear the specialization
  if (!specializationType) {
    person.specialization = null;
    addLogEntry(`${person.name} no longer has a specialization.`, 'info');
    updatePartyDisplay();
    updateGameState();
    return;
  }

  // Otherwise set the specialization
  if (person.setSpecialization(specializationType)) {
    updatePartyDisplay();
    updateGameState();
  }
}

/**
 * Performs an action for a party member.
 * @param {number} personIndex - The index of the party member.
 * @param {string} action - The action to perform ('eat', 'drink', or 'sleep').
 */
export function performAction(personIndex, action) {
  const person = gameState.party[personIndex];
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  const isBusy = gameState.busyUntil[personIndex] > currentTime;
  const isResting = gameState.busyUntil[personIndex] === -1;

  if (isBusy || isResting) {
    console.log("This person is busy or resting and cannot perform actions.");
    return;
  }

  const actions = {
    eat: () => {
      if (gameState.food >= 5) {
        person.hunger = Math.min(100, person.hunger + 25);
        gameState.food -= 5;
        gameState.busyUntil[personIndex] = currentTime + 1;
        addLogEntry(`${person.name} ate some food.`, 'info');
      }
    },
    drink: () => {
      if (gameState.water >= 3) {
        person.thirst = Math.min(100, person.thirst + 25);
        gameState.water -= 3;
        gameState.busyUntil[personIndex] = currentTime + 1;
        addLogEntry(`${person.name} drank some water.`, 'info');
      }
    },
    sleep: () => {
      gameState.busyUntil[personIndex] = -1;
      addLogEntry(`${person.name} started resting.`, 'info');
    }
  };

  if (action in actions) {
    actions[action]();
    updatePartyDisplay();
    updateGameState();
  } else {
    console.log(`Unknown action: ${action}`);
  }
}

/**
 * Checks the status of all party members and triggers game over if all are dead.
 */
export function checkPartyStatus() {
  const allDead = gameState.party.every(member => {
    if (member.health <= 0) {
      member.isDead = true;
      return true;
    }
    return false;
  });

  if (allDead) {
    gameOver();
  }
}

export function isBusy(personIndex, currentTime) {
  return gameState.busyUntil[personIndex] > currentTime || gameState.busyUntil[personIndex] === -1;
}



================================================
FILE: javascript/randomevents.js
================================================
import { gameState } from './settings.js';
import { addLogEntry } from './log.js';
import { updateGameState } from './game.js';
import { getIllnessChanceReduction } from './medicaltent.js';
import { increaseContentment, decreaseContentment } from './contentment.js';

const WHISPERS = [
  "The shadows grow longer...",
  "They're watching...",
  "The ground hungers...",
  "The air carries whispers of forgotten names...",
  "The trees remember...",
  "The water reflects faces that aren't there...",
  "Time is running out...",
  "The old ones stir in their slumber...",
  "The moon weeps blood...",
  "Forgotten rituals yearn to be performed...",
  "The wind carries the scent of decay...",
  "Shadows dance without light...",
  "The earth trembles with anticipation...",
  "Whispers of madness grow louder...",
  "The veil between worlds thins...",
  "Ancient symbols appear in the dust...",
  "The silence screams...",
  "Time flows backwards...",
  "Reality bends and warps...",
  "The abyss gazes back...",
  "Nightmares seep into waking hours...",
  "The boundaries of sanity blur...",
  "Forgotten gods demand tribute...",
  "The air grows thick with dread...",
  "Unseen eyes watch from every corner...",
  "The fabric of existence unravels...",
  "Echoes of unspoken words resonate...",
  "The stars align in impossible patterns...",
  "Memories of places never visited surface...",
  "The void between thoughts expands...",
  "Reflections move independently...",
  "Time becomes a tangible substance...",
  "The world breathes with malevolent intent...",
  "Shadows cast by nothing multiply...",
  "Reality's seams become visible...",
  "The weight of eternity presses down..."
];

const RANDOM_EVENTS = [
  { name: "Rainstorm", effect: (state) => { state.water += 50; return "A sudden rainstorm replenished your water supply! (+50 💧)"; }, type: "positive" },
  {
    name: "Wild Animal Attack", effect: (state) => {
      const victim = state.party[Math.floor(Math.random() * state.party.length)];
      victim.health -= 20;
      return `${victim.name} was attacked by a wild animal! (-20 health)`;
    }, type: "negative"
  },
  {
    name: "Food Spoilage", effect: (state) => {
      const spoiled = Math.floor(state.food * 0.2);
      state.food -= spoiled;
      return `Some of your food has spoiled! (-${spoiled} 🍖)`;
    }, type: "negative"
  },
  {
    name: "Lucky Find", effect: (state) => {
      const amount = Math.floor(Math.random() * 46) + 5; // Random number between 5 and 50
      state.food += amount;
      state.water += amount;
      return `You found a hidden cache of supplies! (+${amount} 🍖, +${amount} 💧)`;
    }, type: "positive"
  },
  {
    name: "Windfall", effect: (state) => {
      const woodAmount = Math.floor(Math.random() * 16) + 10; // Random amount between 10 and 25
      state.wood += woodAmount;
      return `A fallen tree provided extra wood! (+${woodAmount} 🪵)`;
    }, type: "positive"
  },
  {
    name: "Mysterious Illness", effect: (state) => {
      const illnessChanceReduction = getIllnessChanceReduction();
      if (Math.random() > illnessChanceReduction) {
        state.party.forEach(person => {
          person.health = Math.max(0, person.health - 5);
          person.energy = Math.max(0, person.energy - 10);
        });
        return "A mysterious illness affects everyone in the group! (-5 health, -10 energy for all)";
      }
      return "A mysterious illness threatens the group, but the Medical Tent helps prevent its spread!";
    }, type: "negative"
  },
  {
    name: "Morale Boost", effect: (state) => {
      state.party.forEach(person => {
        person.energy = Math.min(person.traits.maxEnergy, person.energy + 20);
      });
      return "A surge of hope boosts everyone's morale! (+20 energy for all)";
    }, type: "positive"
  },
  {
    name: "Tool Breaking", effect: (state) => {
      state.wood -= 10;
      return "One of your tools broke! (-10 🪵)";
    }, type: "negative"
  },
  {
    name: "Bountiful Harvest", effect: (state) => {
      if (state.upgrades.farming) {
        const bonus = Math.floor(Math.random() * 30) + 20;
        state.food += bonus;
        return `Your crops yielded an exceptional harvest! (+${bonus} 🍖)`;
      }
      return "Your crops look healthy!";
    }, type: "positive"
  },
  {
    name: "Water Contamination", effect: (state) => {
      const lost = Math.floor(state.water * 0.3);
      state.water -= lost;
      return `Some of your water got contaminated! (-${lost} 💧)`;
    }, type: "negative"
  },
  {
    name: "Unexpected Visitor", effect: (state) => {
      const foodGain = Math.floor(Math.random() * 20) + 10;
      state.food += foodGain;
      return `A friendly traveler shared some food with your group! (+${foodGain} 🍖)`;
    }, type: "positive"
  },
  {
    name: "Tool Upgrade", effect: (state) => {
      state.party.forEach(person => {
        person.traits.maxEnergy += 10;
      });
      return "You've found ways to improve your tools! (+10 max energy for all)";
    }, type: "positive"
  },
  {
    name: "Harsh Weather", effect: (state) => {
      state.party.forEach(person => {
        person.energy = Math.max(0, person.energy - 15);
      });
      return "A spell of harsh weather has drained everyone's energy! (-15 energy for all)";
    }, type: "negative"
  },
  {
    name: "Natural Spring", effect: (state) => {
      const waterGain = Math.floor(Math.random() * 40) + 20;
      state.water += waterGain;
      return `You've discovered a natural spring! (+${waterGain} 💧)`;
    }, type: "positive"
  },
  {
    name: "Wildlife Stampede", effect: (state) => {
      const foodLoss = Math.floor(state.food * 0.15);
      state.food -= foodLoss;
      return `A stampede of animals trampled some of your food stores! (-${foodLoss} 🍖)`;
    }, type: "negative"
  },
  {
    name: "Ancient Knowledge", effect: (state) => {
      if (state.upgrades.farming) {
        state.farming.maxCrops += 5;
        return "You've uncovered ancient farming techniques! (+5 max crop capacity)";
      }
      return "You've found some interesting old documents.";
    }, type: "positive"
  },
  {
    name: "Unexpected Frost", effect: (state) => {
      if (state.upgrades.farming) {
        state.farming.grid.forEach(row => {
          row.forEach(crop => {
            if (crop) crop.plantedAt += 12; // Delay growth
          });
        });
        return "An unexpected frost has slowed the growth of your crops! (12 hour delay)";
      }
      return "There was an unexpected frost last night.";
    }, type: "negative"
  },
  {
    name: "Community Spirit", effect: (state) => {
      const energyGain = 25;
      state.party.forEach(person => {
        person.energy = Math.min(person.traits.maxEnergy, person.energy + energyGain);
      });
      return `A wave of community spirit energizes everyone! (+${energyGain} energy for all)`;
    }, type: "positive"
  },
  {
    name: "Tool Innovation", effect: (state) => {
      state.staminaPerAction = Math.max(5, state.staminaPerAction - 2);
      return "You've found a way to make your tools more efficient! (-2 stamina cost per action)";
    }, type: "positive"
  },
  {
    name: "Solar Flare", effect: (state) => {
      state.party.forEach(person => {
        person.energy = Math.max(0, person.energy - 20);
      });
      return "A solar flare disrupts sleep patterns! (-20 energy for all)";
    }, type: "negative"
  },
  {
    name: "Meteor Shower", effect: (state) => {
      const resourceGain = Math.floor(Math.random() * 20) + 10;
      state.wood += resourceGain;
      state.food += resourceGain;
      return `A meteor shower brings rare minerals! (+${resourceGain} 🪵, +${resourceGain} 🍖)`;
    }, type: "positive"
  },
  {
    name: "Locust Swarm", effect: (state) => {
      if (state.upgrades.farming) {
        const foodLoss = Math.floor(state.food * 0.25);
        state.food -= foodLoss;
        return `A locust swarm devours your crops! (-${foodLoss} 🍖)`;
      }
      return "A locust swarm passes through the area.";
    }, type: "negative"
  },
  {
    name: "Inspiring Dream", effect: (state) => {
      const luckyPerson = state.party[Math.floor(Math.random() * state.party.length)];
      luckyPerson.traits.maxEnergy += 20;
      return `${luckyPerson.name} had an inspiring dream! (+20 max energy)`;
    }, type: "positive"
  },
  {
    name: "Earthquake", effect: (state) => {
      const woodLoss = Math.floor(state.wood * 0.2);
      state.wood -= woodLoss;
      return `An earthquake damages some structures! (-${woodLoss} 🪵)`;
    }, type: "negative"
  },
  {
    name: "Shooting Star", effect: (state) => {
      state.party.forEach(person => {
        person.health = Math.min(100, person.health + 10);
      });
      return "A shooting star boosts everyone's spirits! (+10 health for all)";
    }, type: "positive"
  },
  {
    name: "Time Anomaly", effect: (state) => {
      const timeJump = Math.floor(Math.random() * 12) + 1;
      state.hour = (state.hour + timeJump) % 24;
      return `A strange time anomaly occurs! (${timeJump} hours pass instantly)`;
    }, type: "neutral"
  },
  {
    name: "Alien Artifact", effect: (state) => {
      const randomPerson = state.party[Math.floor(Math.random() * state.party.length)];
      randomPerson.traits.maxEnergy += 30;
      randomPerson.health = 100;
      return `${randomPerson.name} found an alien artifact! (+30 max energy, full health)`;
    }, type: "positive"
  },
  {
    name: "Cosmic Ray", effect: (state) => {
      const unluckyPerson = state.party[Math.floor(Math.random() * state.party.length)];
      unluckyPerson.health = Math.max(1, unluckyPerson.health - 30);
      return `${unluckyPerson.name} was hit by a cosmic ray! (-30 health)`;
    }, type: "negative"
  },
  {
    name: "Quantum Fluctuation", effect: (state) => {
      const resourceChange = Math.floor(Math.random() * 50) - 25; // -25 to +25
      state.food += resourceChange;
      state.water += resourceChange;
      state.wood += resourceChange;
      return `A quantum fluctuation alters reality! (${resourceChange > 0 ? '+' : ''}${resourceChange} to all resources)`;
    }, type: "neutral"
  },
  {
    name: "Moment of Hope",
    effect: (state) => {
      increaseContentment(10, "moment of hope");
      return "The party shares stories of better times, boosting everyone's spirits. (+10 contentment)";
    },
    type: "positive"
  },
  {
    name: "Successful Hunt",
    effect: (state) => {
      state.food += 30;
      increaseContentment(5, "successful hunt");
      return "A successful hunt provides extra food and lifts the party's spirits! (+30 🥩, +5 contentment)";
    },
    type: "positive"
  },
  {
    name: "Beautiful Sunset",
    effect: (state) => {
      increaseContentment(8, "beautiful sunset");
      return "A breathtaking sunset reminds everyone of the beauty still left in the world. (+8 contentment)";
    },
    type: "positive"
  },
  {
    name: "Grim Reminder",
    effect: (state) => {
      decreaseContentment(10, "grim reminder");
      return "The party stumbles upon evidence of the apocalypse's devastation, dampening everyone's mood. (-10 contentment)";
    },
    type: "negative"
  },
  {
    name: "Argument",
    effect: (state) => {
      decreaseContentment(8, "party argument");
      return "An argument breaks out among party members over dwindling resources. (-8 contentment)";
    },
    type: "negative"
  },
  {
    name: "Nightmare",
    effect: (state) => {
      decreaseContentment(5, "shared nightmare");
      return "Several party members experience the same disturbing nightmare, leaving everyone on edge. (-5 contentment)";
    },
    type: "negative"
  },
  {
    name: "Found Supplies",
    effect: (state) => {
      state.food += 15;
      state.water += 15;
      state.wood += 15;
      increaseContentment(12, "found supplies");
      return "The party discovers a cache of supplies hidden away! (+15 🥩, +15 💧, +15 🌲, +12 contentment)";
    },
    type: "positive"
  },
  {
    name: "Harsh Weather",
    effect: (state) => {
      state.wood -= 10;
      decreaseContentment(7, "harsh weather");
      return "Harsh weather conditions force the party to burn extra wood for warmth and damages morale. (-10 🌲, -7 contentment)";
    },
    type: "negative"
  }
];

export function checkForRandomEvent() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;

  // Check if it's time for a new event (every 12 hours)
  if (currentTime >= gameState.nextEventTime) {
    // 25% chance for a whisper instead of a regular event
    if (Math.random() < 0.25) {
      const whisper = WHISPERS[Math.floor(Math.random() * WHISPERS.length)];
      addLogEntry(`The Whispers: "${whisper}"`, 'whisper');
    } else {
      // Select a single random event with higher chance for positive events
      const eventTypeRoll = Math.random();
      let event;
      if (eventTypeRoll < 0.6) { // 60% chance for positive event
        event = RANDOM_EVENTS.filter(e => e.type === 'positive')[Math.floor(Math.random() * RANDOM_EVENTS.filter(e => e.type === 'positive').length)];
      } else if (eventTypeRoll < 0.8) { // 20% chance for neutral event
        event = RANDOM_EVENTS.filter(e => e.type === 'neutral')[Math.floor(Math.random() * RANDOM_EVENTS.filter(e => e.type === 'neutral').length)];
      } else { // 20% chance for negative event
        event = RANDOM_EVENTS.filter(e => e.type === 'negative')[Math.floor(Math.random() * RANDOM_EVENTS.filter(e => e.type === 'negative').length)];
      }
      const message = event.effect(gameState);
      addLogEntry(`Random Event: ${event.name}. ${message}`, event.type);
    }

    // Set the next event time (between 12 and 24 hours from now)
    gameState.nextEventTime = currentTime + 12 + Math.floor(Math.random() * 12);

    // Update game state after the event
    updateGameState();
  }
}

export function initializeRandomEvents() {
  if (!gameState.nextEventTime) {
    const currentTime = gameState.hour + (gameState.day - 1) * 24;
    gameState.nextEventTime = currentTime + Math.floor(Math.random() * 12); // First event within 12 hours
  }
}


================================================
FILE: javascript/settings.js
================================================
/**
 * Game Settings Module
 * This module defines constant values and initial game state used throughout the game.
 */

// Time interval (in milliseconds) between game ticks
export const TICK_INTERVAL = 1500;

/**
 * Starting resources for each difficulty level
 * @type {Object.<string, {food: number, water: number, wood: number}>}
 */
export const STARTING_RESOURCES = {
  easy: { food: 50, water: 50, wood: 50 },
  medium: { food: 25, water: 25, wood: 25 },
  hard: { food: 0, water: 0, wood: 0 }
};

/**
 * Initial game state object
 * @type {Object}
 */
export const initialGameState = {
  version: 5,
  automations: {},
  day: 1,
  hour: 1,
  difficulty: null,
  food: 0,
  water: 0,
  wood: 0,
  knowledgePoints: 0,
  contentmentLevel: 50,
  maxContentment: 100,
  contentmentEffects: {
    resourceEfficiency: 0,
    energyConsumption: 0,
    corruptionResistance: 0
  },
  party: [],
  upgrades: {},
  technologies: {},
  activeResearch: null,
  lumberMill: {
    trees: [],
    maxTrees: 5,
    baseGrowthTime: 24,
    growthTimeVariance: 12,
    baseHarvestAmount: 10,
    harvestAmountVariance: 5
  },
  achievements: {},
  totalResourcesGathered: { food: 0, water: 0, wood: 0 },
  totalActions: 0,
  totalPlayTime: 0,
  totalCropsHarvested: 0,
  totalAnimalsHunted: 0,
  totalWellWaterCollected: 0,
  totalKnowledgePointsGained: 0,
  watchtower: {
    lastRescueMissionDay: 0,
    rescueMissionAvailable: true,
    rescueMission: null
  },
  hunting: {
    animals: []
  },
  resourceEfficiency: 1,
  waterPurificationActive: false
};

// Current game state, initialized with the initial game state
export let gameState = { ...initialGameState };

/**
 * Resets the game state to its initial values
 */
export function resetGameState() {
  gameState = { ...initialGameState };
}

/**
 * Upgrades object
 * @type {Object.<string, {id: string, name: string, cost: Object.<string, number>, effect: string, prerequisite: string, available: boolean}>}
 */
export const UPGRADES = {
  farming: {
    id: 'farming',
    name: 'Farming',
    cost: { food: 80 },
    effect: 'Allows you to grow your own food',
    available: true
  },
  well: {
    id: 'well',
    name: 'Well',
    cost: { wood: 80 },
    effect: 'Generates water over time',
    prerequisite: 'farming'
  },
  advancedFarming: {
    id: 'advancedFarming',
    name: 'Advanced Farming Techniques',
    cost: { food: 300 },
    effect: 'Increases crop yield by 50% and reduces growth time by 25%',
    prerequisite: 'farming'
  },
  waterPurification: {
    id: 'waterPurification',
    name: 'Water Purification System',
    cost: { water: 250, wood: 100 },
    effect: 'Reduces water consumption by 20% for all activities',
    prerequisite: 'well'
  },
  toolWorkshop: {
    id: 'toolWorkshop',
    name: 'Tool Workshop',
    cost: { wood: 400 },
    effect: 'Increases resource gathering efficiency by 25% (more resources per action)',
    available: true
  },
  medicalTent: {
    id: 'medicalTent',
    name: 'Medical Tent',
    cost: { food: 200, wood: 150 },
    effect: 'Slowly heals injured party members over time and reduces the chance of illness',
    available: true
  },
  huntingLodge: {
    id: 'huntingLodge',
    name: 'Hunting Lodge',
    cost: { wood: 300, food: 100 },
    effect: 'Unlocks a new "Hunt" action that has a chance to provide a large amount of food',
    available: true
  },
  lumberMill: {
    id: 'lumberMill',
    name: 'Lumber Mill',
    cost: { wood: 300, food: 100 },
    effect: 'Increases wood gathering efficiency by 50% and generates 1 wood per hour',
    prerequisite: 'toolWorkshop'
  },
  watchtower: {
    id: 'watchtower',
    name: 'Watchtower',
    cost: { wood: 500, food: 200 },
    effect: 'Allows you to spot and rescue potential survivors',
    prerequisite: 'huntingLodge'
  },
  automatedFeeding: {
    id: 'automatedFeeding',
    name: 'Automated Feeding System',
    cost: { food: 500, wood: 200 },
    effect: 'Automatically feeds party members when their hunger drops below 20%',
    prerequisite: 'farming'
  },
  waterPurificationSystem: {
    id: 'waterPurificationSystem',
    name: 'Water Purification and Distribution',
    cost: { water: 400, wood: 200 },
    effect: 'Automatically provides water to party members when their thirst drops below 20%',
    prerequisite: 'well'
  },
  comfortableSleepingQuarters: {
    id: 'comfortableSleepingQuarters',
    name: 'Comfortable Sleeping Quarters',
    cost: { wood: 400, food: 200 },
    effect: 'Automatically rests party members when their energy drops below 20%',
    prerequisite: 'toolWorkshop'
  },
  foodGatheringDrone: {
    id: 'foodGatheringDrone',
    name: 'Food Gathering Drone',
    cost: { wood: 300, food: 200 },
    effect: 'Automatically gathers small amounts of food over time',
    prerequisite: 'huntingLodge'
  },
  waterGatheringDrone: {
    id: 'waterGatheringDrone',
    name: 'Water Gathering Drone',
    cost: { wood: 300, water: 200 },
    effect: 'Automatically gathers small amounts of water over time',
    prerequisite: 'well'
  },
  woodGatheringDrone: {
    id: 'woodGatheringDrone',
    name: 'Wood Gathering Drone',
    cost: { wood: 400, food: 100 },
    effect: 'Automatically gathers small amounts of wood over time',
    prerequisite: 'lumberMill'
  },
  specializations: {
    id: 'specializations',
    name: 'Specialization Training',
    cost: { food: 250, wood: 150, knowledgePoints: 5 },
    effect: 'Allows party members to specialize in different roles for unique bonuses',
    available: true
  }
};

// Add this function to scale upgrade costs
export function getScaledUpgradeCost(baseUpgradeCost) {
  const scaleFactor = 1 + (gameState.day / 20); // Costs increase by 5% every 20 days
  return Math.floor(baseUpgradeCost * scaleFactor);
}


================================================
FILE: javascript/shortcuts-modal.js
================================================
/**
 * Manages the shortcuts help modal and shortcuts visibility toggle
 */

// Track if shortcuts are visible - default to false on mobile
let shortcutsVisible = window.innerWidth > 800;

// Create and append modal HTML
const modalHTML = `
<div id="shortcuts-modal" class="modal hidden">
  <div class="modal-content">
    <header>
      <h2><i data-lucide="keyboard" class="icon"></i> Keyboard Shortcuts</h2>
      <button class="close-modal"><i data-lucide="x" class="icon"></i></button>
    </header>
    
    <div class="shortcuts-toggle">
      <label>
        <input type="checkbox" id="shortcuts-toggle" ${window.innerWidth > 800 ? 'checked' : ''}>
        Show shortcuts in game
      </label>
    </div>

    <div class="shortcuts-list">
      <ul>
        <li><kbd>H</kbd> Toggle shortcuts help</li>
      </ul>

      <h3>Game Controls</h3>
      <ul>
        <li><kbd>Q</kbd> Gather Food</li>
        <li><kbd>W</kbd> Collect Water</li>
        <li><kbd>E</kbd> Chop Wood</li>
      </ul>
      
      <h3>Party Members</h3>
      <table>
        <tr>
          <th>Member 1</th>
          <th>Member 2</th>
          <th>Member 3</th>
        </tr>
        <tr>
          <td><kbd>U</kbd> Eat</td>
          <td><kbd>J</kbd> Eat</td>
          <td><kbd>M</kbd> Eat</td>
        </tr>
        <tr>
          <td><kbd>I</kbd> Drink</td>
          <td><kbd>K</kbd> Drink</td>
          <td><kbd>,</kbd> Drink</td>
        </tr>
        <tr>
          <td><kbd>O</kbd> Rest</td>
          <td><kbd>L</kbd> Rest</td>
          <td><kbd>.</kbd> Rest</td>
        </tr>
      </table>
    </div>
  </div>
</div>
`;

export function initializeShortcutsModal() {
  // Append modal to body
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  
  // Set initial state for shortcuts visibility
  document.body.classList.toggle('hide-shortcuts', !shortcutsVisible);
  
  const modal = document.getElementById('shortcuts-modal');
  const closeBtn = modal.querySelector('.close-modal');
  const toggleCheckbox = document.getElementById('shortcuts-toggle');
  const shortcutsBtn = document.getElementById('shortcuts-help');

  // Show modal when shortcuts button is clicked
  shortcutsBtn.addEventListener('click', () => {
    modal.classList.remove('hidden');
  });

  // Close modal when close button is clicked
  closeBtn.addEventListener('click', () => {
    modal.classList.add('hidden');
  });

  // Close modal when clicking outside
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      modal.classList.add('hidden');
    }
  });

  // Handle shortcuts visibility toggle
  toggleCheckbox.addEventListener('change', () => {
    shortcutsVisible = toggleCheckbox.checked;
    document.body.classList.toggle('hide-shortcuts', !shortcutsVisible);
  });
} 


================================================
FILE: javascript/shortcuts.js
================================================
/**
 * Handles keyboard shortcuts for selecting game difficulty and game actions
 * Shortcuts:
 * - 'a' for Easy
 * - 's' for Medium
 * - 'd' for Hard
 * - 'h' to open shortcuts help
 * - 'q' to gather food
 * - 'w' to collect water
 * - 'e' to chop wood
 * - Party member 1: 'u'=eat, 'i'=drink, 'o'=sleep
 * - Party member 2: 'j'=eat, 'k'=drink, 'l'=sleep
 * - Party member 3: 'm'=eat, ','=drink, '.'=sleep
 */
export function initializeShortcuts() {
  // Map keys to difficulty levels
  const DIFFICULTY_SHORTCUTS = {
    'a': 'easy',
    's': 'medium',
    'd': 'hard'
  };

  // Map keys to action buttons
  const ACTION_SHORTCUTS = {
    'q': 'gatherFoodBtn',
    'w': 'collectWaterBtn',
    'e': 'chopWoodBtn'
  };

  // Map keys to party member actions
  const PARTY_SHORTCUTS = {
    'u': { index: 0, action: 'eat' },
    'i': { index: 0, action: 'drink' },
    'o': { index: 0, action: 'sleep' },
    'j': { index: 1, action: 'eat' },
    'k': { index: 1, action: 'drink' },
    'l': { index: 1, action: 'sleep' },
    'm': { index: 2, action: 'eat' },
    ',': { index: 2, action: 'drink' },
    '.': { index: 2, action: 'sleep' }
  };

  // Event listener for keydown events
  document.addEventListener('keydown', (event) => {
    const key = event.key.toLowerCase();

    // Handle help shortcut (works on any screen)
    if (key === 'h') {
      const modal = document.getElementById('shortcuts-modal');
      const shortcutsBtn = document.getElementById('shortcuts-help');
      
      if (modal && !modal.classList.contains('hidden')) {
        modal.classList.add('hidden');
      } else if (shortcutsBtn) {
        shortcutsBtn.click();
      }
      return;
    }

    // Handle party member shortcuts if we're on the game screen
    if (PARTY_SHORTCUTS[key]) {
      const gameScreen = document.getElementById('game_screen');
      if (!gameScreen?.classList.contains('hidden')) {
        const { index, action } = PARTY_SHORTCUTS[key];
        const button = document.querySelector(`button[data-action="${action}"][data-person="${index}"]:not([disabled])`);
        if (button) {
          button.click();
        }
      }
      return;
    }

    // Handle action shortcuts if we're on the game screen
    if (ACTION_SHORTCUTS[key]) {
      const gameScreen = document.getElementById('game_screen');
      if (!gameScreen?.classList.contains('hidden')) {
        const button = document.getElementById(ACTION_SHORTCUTS[key]);
        if (button) {
          button.click();
        }
      }
      return;
    }

    // Only process difficulty shortcuts if we're on the start screen
    const startScreen = document.getElementById('game_start_screen');
    if (startScreen?.classList.contains('hidden')) return;
    
    // Check if the pressed key matches any of our shortcuts
    if (DIFFICULTY_SHORTCUTS[key]) {
      // Find and click the corresponding difficulty button
      const button = document.querySelector(`button[data-difficulty="${DIFFICULTY_SHORTCUTS[key]}"]`);
      if (button) {
        button.click();
      }
    }
  });
} 


================================================
FILE: javascript/specializations.js
================================================
/*
  Specializations Module
  This module defines the different specializations that party members can have.
  Each specialization provides unique bonuses and abilities to party members.
*/

/**
 * Object containing all available specialization types for party members.
 * Each specialization has a unique bonus and description.
 */
export const specializationTypes = {
  gatherer: {
    id: "gatherer",
    name: "Gatherer",
    icon: "axe",
    description: "25% more resources from gathering actions",
    resourceBonus: 0.25,
    expeditionLootBonus: 0.1,
    specialAbility: "quickGathering" // 1-hour action for resources
  },
  builder: {
    id: "builder",
    name: "Builder",
    icon: "hammer",
    description: "20% reduced wood cost for buildings",
    woodCostReduction: 0.2,
    buildingQualityBonus: 0.1,
    specialAbility: "rapidConstruction" // Speed up current building
  },
  researcher: {
    id: "researcher",
    name: "Researcher",
    icon: "book",
    description: "Generates 0.5 knowledge points per hour",
    knowledgeGeneration: 0.5,
    researchSpeedBonus: 0.15,
    specialAbility: "insight" // Reveal random technology
  },
  fighter: {
    id: "fighter",
    name: "Fighter",
    icon: "sword",
    description: "25% more effective in combat",
    combatBonus: 0.25,
    expeditionRiskReduction: 0.1,
    specialAbility: "protect" // Reduce party damage in combat
  },
  medic: {
    id: "medic",
    name: "Medic",
    icon: "heart-pulse",
    description: "30% more effective medicine and +2 health regeneration per day",
    medicineEffectiveness: 0.3,
    healthRegeneration: 2,
    specialAbility: "emergencyTreatment" // Instant partial heal
  }
};

/**
 * Gets the specialization bonus for a specific resource type.
 * @param {string} specializationType - The type of specialization.
 * @param {string} resourceType - The type of resource.
 * @returns {number} The bonus multiplier for the resource.
 */
export function getSpecializationBonus(specializationType, resourceType) {
  if (specializationType === "gatherer") {
    return 1.25; // 25% bonus to all resource gathering
  }
  return 1; // No bonus for other specializations or resource types
}

/**
 * Applies the specialization effects to a party member.
 * @param {Object} partyMember - The party member to apply effects to.
 */
export function applySpecializationEffects(partyMember) {
  if (!partyMember.specialization) return;

  const specialization = specializationTypes[partyMember.specialization];
  if (!specialization) return;

  // Apply health regeneration for medics
  if (partyMember.specialization === "medic" && partyMember.health < 100) {
    partyMember.health = Math.min(100, partyMember.health + specialization.healthRegeneration / 24); // Divide by 24 to get hourly rate
  }

  // Additional effects can be added here as the game expands
}

/**
 * Gets the wood cost reduction for buildings if the party member is a builder.
 * @param {Object} partyMember - The party member to check.
 * @returns {number} The reduction multiplier for wood costs.
 */
export function getWoodCostReduction(partyMember) {
  if (partyMember.specialization === "builder") {
    return 1 - specializationTypes.builder.woodCostReduction; // 20% reduction
  }
  return 1; // No reduction
}

/**
 * Gets the knowledge generation per hour if the party member is a researcher.
 * @param {Object} partyMember - The party member to check.
 * @returns {number} The amount of knowledge generated per hour.
 */
export function getKnowledgeGeneration(partyMember) {
  if (partyMember.specialization === "researcher") {
    return specializationTypes.researcher.knowledgeGeneration;
  }
  return 0;
} 


================================================
FILE: javascript/storage.js
================================================
/**
 * Storage Module
 * Handles saving, loading, and clearing game state using localStorage.
 */

import { TICK_INTERVAL, gameState, initialGameState } from './settings.js';

const STORAGE_KEY = 'societyFail';

/**
 * Saves the current game state to localStorage.
 */
export function saveGameState() {
  const saveData = {
    ...gameState,
    lastSaved: Date.now(),
    collapseState: gameState.collapseState || {}
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(saveData));
}

/**
 * Loads the saved game state from localStorage and updates it based on elapsed time.
 * @returns {Object|null} The loaded and updated game state or null if no save exists.
 */
export function loadGameState() {
  const savedData = localStorage.getItem(STORAGE_KEY);
  if (!savedData) return null;

  const loadedState = JSON.parse(savedData);

  // Check if the saved version is compatible with the current version
  if (loadedState.version !== initialGameState.version) {
    return 'incompatible';
  }

  // Calculate elapsed time and update game state
  const elapsedTime = Date.now() - loadedState.lastSaved;
  const elapsedTicks = Math.floor(elapsedTime / TICK_INTERVAL);

  loadedState.hour += elapsedTicks;
  loadedState.day += Math.floor(loadedState.hour / 24);
  loadedState.hour %= 24;

  // Ensure collapseState exists
  loadedState.collapseState = loadedState.collapseState || {};

  // Ensure technologies and activeResearch exist
  loadedState.technologies = loadedState.technologies || {};
  loadedState.activeResearch = loadedState.activeResearch || null;

  // Update research progress if there's active research
  if (loadedState.activeResearch) {
    const currentTime = loadedState.day * 24 + loadedState.hour;
    const elapsedResearchTime = currentTime - loadedState.activeResearch.startTime;
    const progress = Math.min(elapsedResearchTime / loadedState.activeResearch.totalTime, 1);

    // Update progress in the technology
    if (loadedState.technologies[loadedState.activeResearch.id]) {
      loadedState.technologies[loadedState.activeResearch.id].progress = progress;
    }

    // If research is complete, mark it for completion after loading
    if (progress >= 1) {
      loadedState.completePendingResearch = loadedState.activeResearch.id;
      loadedState.activeResearch = null;
    }
  }

  return loadedState;
}

/**
 * Removes the saved game state from localStorage.
 */
export function clearGameState() {
  localStorage.removeItem(STORAGE_KEY);
}

/**
 * Saves the collapse state of a module.
 * @param {string} moduleId - The ID of the module.
 * @param {boolean} isCollapsed - Whether the module is collapsed.
 */
export function saveCollapseState(moduleId, isCollapsed) {
  gameState.collapseState = gameState.collapseState || {};
  gameState.collapseState[moduleId] = isCollapsed;
  saveGameState();
}

/**
 * Loads the collapse state of a module.
 * @param {string} moduleId - The ID of the module.
 * @returns {boolean|null} The collapse state of the module or null if not found.
 */
export function loadCollapseState(moduleId) {
  return gameState.collapseState && gameState.collapseState[moduleId] !== undefined
    ? gameState.collapseState[moduleId]
    : null;
}


================================================
FILE: javascript/technologies.js
================================================
/**
 * Technologies Module
 * Handles the technology research tree system, which extends beyond the existing Upgrades system.
 * Technologies require knowledge points and time to research, unlike upgrades which apply immediately.
 */

import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';
import { saveGameState } from './storage.js';
import { unlockSecondaryModule } from './upgrades.js';

/**
 * Technology definitions with their costs, research times, effects, and prerequisites
 */
export const TECHNOLOGIES = {
  improvedTools: {
    id: "improvedTools",
    name: "Improved Tools",
    knowledgeCost: 10,
    researchTime: 4, // hours
    effect: "Increase resource gathering by 20%",
    prerequisites: [],
    unlocked: false,
    researched: false,
    category: "survival",
    icon: "anvil"
  },
  advancedFarming: {
    id: "advancedFarming",
    name: "Advanced Farming",
    knowledgeCost: 25,
    researchTime: 8,
    effect: "50% more food from crops",
    prerequisites: ["improvedTools"],
    unlocked: false,
    researched: false,
    category: "farming",
    icon: "sprout"
  },
  waterPurification: {
    id: "waterPurification",
    name: "Water Purification",
    knowledgeCost: 25,
    researchTime: 8,
    effect: "20% less water consumption",
    prerequisites: ["improvedTools"],
    unlocked: false,
    researched: false,
    category: "survival",
    icon: "droplets"
  },
  betterConstruction: {
    id: "betterConstruction",
    name: "Better Construction",
    knowledgeCost: 30,
    researchTime: 12,
    effect: "Buildings cost 25% less wood",
    prerequisites: ["improvedTools"],
    unlocked: false,
    researched: false,
    category: "building",
    icon: "hammer"
  },
  medicinalHerbs: {
    id: "medicinalHerbs",
    name: "Medicinal Herbs",
    knowledgeCost: 40,
    researchTime: 16,
    effect: "Party members heal 5% health per day",
    prerequisites: ["advancedFarming"],
    unlocked: false,
    researched: false,
    category: "medicine",
    icon: "leaf"
  }
};

/**
 * Initializes the technology system
 */
export function initializeTechnologies() {
  // Initialize technologies in gameState if not already present
  if (!gameState.technologies) {
    gameState.technologies = {};
  }

  // Initialize activeResearch if not already present
  if (!gameState.activeResearch) {
    gameState.activeResearch = null;
  }

  // Check which technologies should be unlocked based on prerequisites
  checkTechnologyAvailability();

  // Update the UI
  updateTechnologiesUI();
}

/**
 * Starts research on a technology
 * @param {string} techId - The ID of the technology to research
 */
export function startResearch(techId) {
  const tech = TECHNOLOGIES[techId];

  // Check if the technology exists and is not already researched
  if (!tech || gameState.technologies[techId]?.researched) {
    return;
  }

  // Check if another research is already in progress
  if (gameState.activeResearch) {
    addLogEntry(`Cannot start research on ${tech.name}. Another research is already in progress.`, 'error');
    return;
  }

  // Check if the player can afford the knowledge cost
  if (gameState.knowledgePoints < tech.knowledgeCost) {
    addLogEntry(`Not enough knowledge points to research ${tech.name}.`, 'error');
    return;
  }

  // Deduct the knowledge cost
  gameState.knowledgePoints -= tech.knowledgeCost;

  // Initialize the technology in gameState if not already present
  if (!gameState.technologies[techId]) {
    gameState.technologies[techId] = {
      progress: 0,
      researched: false
    };
  }

  // Set as active research
  gameState.activeResearch = {
    id: techId,
    startTime: gameState.day * 24 + gameState.hour,
    totalTime: tech.researchTime
  };

  addLogEntry(`Started research on ${tech.name}.`, 'success');
  updateGameState();
  updateTechnologiesUI();
  saveGameState();
}

/**
 * Updates research progress during game ticks
 */
export function updateResearchProgress() {
  if (!gameState.activeResearch) {
    return;
  }

  const techId = gameState.activeResearch.id;
  const tech = TECHNOLOGIES[techId];

  if (!tech) {
    gameState.activeResearch = null;
    return;
  }

  // Calculate current progress
  const currentTime = gameState.day * 24 + gameState.hour;
  const elapsedTime = currentTime - gameState.activeResearch.startTime;
  const progress = Math.min(elapsedTime / tech.researchTime, 1);

  // Update progress in gameState
  gameState.technologies[techId].progress = progress;

  // Check if research is complete
  if (progress >= 1) {
    completeResearch(techId);
  }
}

/**
 * Completes research on a technology and applies its effects
 * @param {string} techId - The ID of the technology to complete
 */
export function completeResearch(techId) {
  const tech = TECHNOLOGIES[techId];

  if (!tech) {
    return;
  }

  // Mark as researched
  gameState.technologies[techId].researched = true;
  gameState.technologies[techId].progress = 1;

  // Clear active research
  gameState.activeResearch = null;

  // Apply technology effects
  applyTechnologyEffects(techId);

  // Check for newly available technologies
  checkTechnologyAvailability();

  addLogEntry(`Research complete: ${tech.name}`, 'success');
  updateGameState();
  updateTechnologiesUI();
  saveGameState();
}

/**
 * Checks which technologies should be available based on prerequisites
 */
export function checkTechnologyAvailability() {
  for (const techId in TECHNOLOGIES) {
    const tech = TECHNOLOGIES[techId];

    // Skip if already unlocked
    if (tech.unlocked) {
      continue;
    }

    // Check prerequisites
    let allPrerequisitesMet = true;
    for (const prereqId of tech.prerequisites) {
      if (!gameState.technologies[prereqId]?.researched) {
        allPrerequisitesMet = false;
        break;
      }
    }

    // Unlock if all prerequisites are met
    if (allPrerequisitesMet) {
      tech.unlocked = true;
    }
  }
}

/**
 * Applies the effects of a researched technology
 * @param {string} techId - The ID of the technology to apply
 */
export function applyTechnologyEffects(techId) {
  switch (techId) {
    case 'improvedTools':
      // Increase resource gathering efficiency by 20%
      gameState.resourceEfficiency *= 1.2;
      break;
    case 'advancedFarming':
      // 50% more food from crops - will be handled in farming.js
      break;
    case 'waterPurification':
      // 20% less water consumption
      gameState.waterPurificationActive = true;
      break;
    case 'betterConstruction':
      // 25% less wood cost for buildings - will be applied when calculating costs
      break;
    case 'medicinalHerbs':
      // Party members heal 5% health per day - will be applied in updatePartyStats
      break;
  }
}

/**
 * Updates the technologies UI
 */
export function updateTechnologiesUI() {
  const techModule = document.getElementById('technology-module');
  if (!techModule) return;

  // Clear existing content
  const moduleContent = techModule.querySelector('.module-content');
  if (!moduleContent) return;
  moduleContent.innerHTML = '';

  // Create category filters
  const categories = [...new Set(Object.values(TECHNOLOGIES).map(tech => tech.category))];
  const filterContainer = document.createElement('div');
  filterContainer.className = 'tech-category-filters';

  // Add "All" filter
  const allFilter = document.createElement('button');
  allFilter.textContent = 'All';
  allFilter.className = 'active';
  allFilter.dataset.category = 'all';
  filterContainer.appendChild(allFilter);

  // Add category filters
  categories.forEach(category => {
    const filter = document.createElement('button');
    filter.textContent = category.charAt(0).toUpperCase() + category.slice(1);
    filter.dataset.category = category;
    filterContainer.appendChild(filter);
  });

  moduleContent.appendChild(filterContainer);

  // Add active research section if there is one
  if (gameState.activeResearch) {
    const activeResearchId = gameState.activeResearch.id;
    const activeTech = TECHNOLOGIES[activeResearchId];

    if (activeTech) {
      const activeResearchSection = document.createElement('div');
      activeResearchSection.className = 'active-research';

      const progress = gameState.technologies[activeResearchId]?.progress || 0;
      const progressPercent = Math.round(progress * 100);
      const timeRemaining = Math.ceil(activeTech.researchTime * (1 - progress));

      activeResearchSection.innerHTML = `
        <h3><i data-lucide="flask-conical" class="lucide"></i> Currently Researching</h3>
        <div class="research-details">
          <strong>${activeTech.name}:</strong> ${activeTech.effect}
        </div>
        <div class="progress-bar">
          <div class="progress" style="width: ${progressPercent}%"></div>
        </div>
        <div class="progress-text">
          <span>${progressPercent}% complete</span>
          <span>${timeRemaining} hours remaining</span>
        </div>
      `;

      moduleContent.appendChild(activeResearchSection);
    }
  }

  // Create technologies container
  const techContainer = document.createElement('div');
  techContainer.className = 'technologies-container';

  // Create technology categories
  const availableTechSection = document.createElement('div');
  availableTechSection.className = 'tech-category available-technologies';
  availableTechSection.innerHTML = '<h3>Available Technologies</h3>';
  const availableTechItems = document.createElement('div');
  availableTechItems.className = 'tech-items';
  availableTechSection.appendChild(availableTechItems);

  const researchedTechSection = document.createElement('div');
  researchedTechSection.className = 'tech-category researched-technologies';
  researchedTechSection.innerHTML = '<h3>Researched Technologies</h3>';
  const researchedTechItems = document.createElement('div');
  researchedTechItems.className = 'tech-items';
  researchedTechSection.appendChild(researchedTechItems);

  const lockedTechSection = document.createElement('div');
  lockedTechSection.className = 'tech-category locked-technologies';
  lockedTechSection.innerHTML = '<h3>Locked Technologies</h3>';
  const lockedTechItems = document.createElement('div');
  lockedTechItems.className = 'tech-items';
  lockedTechSection.appendChild(lockedTechItems);

  // Add technologies to their respective sections
  for (const techId in TECHNOLOGIES) {
    const tech = TECHNOLOGIES[techId];
    const isResearched = gameState.technologies[techId]?.researched;
    const isActiveResearch = gameState.activeResearch?.id === techId;

    // Skip if it's the active research (already displayed)
    if (isActiveResearch) {
      continue;
    }

    const techElement = document.createElement('div');
    techElement.className = `tech-item ${isResearched ? 'researched' : tech.unlocked ? 'available' : 'locked'}`;
    techElement.dataset.techId = techId;
    techElement.dataset.category = tech.category;

    // Create tech header
    const techHeader = document.createElement('div');
    techHeader.className = 'tech-header';

    techHeader.innerHTML = `
      <div class="tech-icon"><i data-lucide="${tech.icon}" class="lucide"></i></div>
      <div class="tech-name">${tech.name}</div>
      <div class="tech-status ${isResearched ? 'researched' : tech.unlocked ? 'available' : 'locked'}">
        ${isResearched ? 'Researched' : tech.unlocked ? 'Available' : 'Locked'}
      </div>
    `;

    techElement.appendChild(techHeader);

    // Create tech content
    const techContent = document.createElement('div');
    techContent.className = 'tech-content';

    let contentHTML = `<div class="tech-effect">${tech.effect}</div>`;

    if (isResearched) {
      // No additional content needed for researched technologies
    } else if (tech.unlocked) {
      contentHTML += `
        <div class="tech-cost">
          <span class="knowledge"><i data-lucide="book" class="lucide"></i> ${tech.knowledgeCost}</span>
          <span class="time"><i data-lucide="clock" class="lucide"></i> ${tech.researchTime} hours</span>
        </div>
        <button class="research-button" data-tech-id="${techId}">Research</button>
      `;
    } else {
      // Show prerequisites for locked technologies
      const prereqNames = tech.prerequisites.map(prereqId => TECHNOLOGIES[prereqId]?.name || prereqId).join(', ');
      contentHTML += `<div class="tech-prerequisites">Requires: ${prereqNames}</div>`;
    }

    techContent.innerHTML = contentHTML;
    techElement.appendChild(techContent);

    // Add to appropriate section
    if (isResearched) {
      researchedTechItems.appendChild(techElement);
    } else if (tech.unlocked) {
      availableTechItems.appendChild(techElement);
    } else {
      lockedTechItems.appendChild(techElement);
    }
  }

  // Add sections to container if they have children beyond the header
  if (availableTechItems.childElementCount > 0) {
    techContainer.appendChild(availableTechSection);
  }

  if (researchedTechItems.childElementCount > 0) {
    techContainer.appendChild(researchedTechSection);
  }

  if (lockedTechItems.childElementCount > 0) {
    techContainer.appendChild(lockedTechSection);
  }

  // If no technologies are available, show a message
  if (techContainer.childElementCount === 0) {
    const noTechMessage = document.createElement('div');
    noTechMessage.className = 'no-technologies';
    noTechMessage.textContent = 'No technologies available yet. Gather more knowledge to unlock technologies.';
    techContainer.appendChild(noTechMessage);
  }

  moduleContent.appendChild(techContainer);

  // Add event listeners
  const researchButtons = techModule.querySelectorAll('.research-button');
  researchButtons.forEach(button => {
    button.addEventListener('click', (event) => {
      const techId = event.target.dataset.techId;
      startResearch(techId);
    });
  });

  // Add category filter functionality
  const categoryFilters = techModule.querySelectorAll('.tech-category-filters button');
  categoryFilters.forEach(filter => {
    filter.addEventListener('click', (event) => {
      // Remove active class from all filters
      categoryFilters.forEach(f => f.classList.remove('active'));

      // Add active class to clicked filter
      event.target.classList.add('active');

      const category = event.target.dataset.category;
      const techItems = techModule.querySelectorAll('.tech-item');

      techItems.forEach(item => {
        if (category === 'all' || item.dataset.category === category) {
          item.style.display = '';
        } else {
          item.style.display = 'none';
        }
      });
    });
  });

  // Initialize Lucide icons
  createLucideIcons();
}

/**
 * Shows the technology module after a specific game milestone
 * @param {boolean} show - Whether to show the module
 */
export function showTechnologyModule(show = true) {
  const techModule = document.getElementById('technology-module');
  if (!techModule) return;

  if (show) {
    techModule.classList.remove('mystery');
    techModule.innerHTML = `
      <div class="tech-header">
        <h2 class="collapsible"><i data-lucide="microscope" class="icon-dark"></i> Technologies <i data-lucide="chevron-up" class="toggle-icon"></i></h2>
      </div>
      <div class="module-content tech-content"></div>
    `;
    updateTechnologiesUI();
  } else {
    techModule.classList.add('mystery');
    techModule.innerHTML = `
      <div class="mystery-content">
        <div class="icon"><i data-lucide="circle-help" class="icon gutter-grey"></i></div>
        <div class="title">Ancient Knowledge</div>
        <div class="description">What secrets await those who seek to understand?</div>
      </div>
    `;
  }

  createLucideIcons();
} 


================================================
FILE: javascript/time.js
================================================
/**
 * Time Module
 * Handles game time progression and display updates.
 */

import { gameState, TICK_INTERVAL } from './settings.js';
import { updateGameState } from './game.js';

let isPaused = false;
let tickInterval = null;
// Add a separate flag for UI interactions
export let isUIInteractionPaused = false;

/**
 * Starts the game time and initializes the tick interval.
 */
export function startTime() {
  updateTimeDisplay();
  tickInterval = setInterval(tick, TICK_INTERVAL);
  // Store the interval in window for global access
  window.gameTickInterval = tickInterval;
}

/**
 * Explicitly pause the game for UI interactions
 * @param {boolean} pause - Whether to pause or resume
 */
export function pauseForUIInteraction(pause) {
  isUIInteractionPaused = pause;
  console.log(`Game ${pause ? 'paused' : 'resumed'} for UI interaction`);
}

/**
 * Progresses game time by one hour and updates the game state.
 */
function tick() {
  if (isPaused || isUIInteractionPaused) return;

  gameState.hour = (gameState.hour % 24) + 1;
  if (gameState.hour === 1) {
    gameState.day++;
  }

  gameState.totalPlayTime += TICK_INTERVAL / 1000; // Convert milliseconds to seconds

  updateTimeDisplay();
  updateGameState();
}

/**
 * Updates the time display in the DOM.
 */
export function updateTimeDisplay() {
  const timeElement = document.getElementById('time');
  if (timeElement) {
    timeElement.textContent = `Day ${gameState.day}, Hour ${gameState.hour}`;
  }
}

/**
 * Toggles the paused state of the game time.
 */
export function togglePause() {
  isPaused = !isPaused;
}

/**
 * Resets the game time to the initial state and stops the timer.
 */
export function resetTime() {
  stopTime();
  gameState.day = 1;
  gameState.hour = 1;
  updateTimeDisplay();
}

/**
 * Stops the game time and clears the tick interval.
 */
export function stopTime() {
  clearInterval(tickInterval);
  tickInterval = null;
  isPaused = false;
}


================================================
FILE: javascript/tutorial.js
================================================
import { gameState, UPGRADES } from './settings.js';
import { addLogEntry } from './log.js';

const TUTORIAL_MESSAGES = [
  {
    id: 'welcome',
    message: "Welcome to the game! Start by gathering resources using the buttons in the Actions panel.",
    trigger: state => state.day === 1 && state.hour === 2
  },
  {
    id: 'first_upgrade',
    message: "You can now afford your first upgrade! Check the Upgrades panel to see what's available.",
    trigger: state => {
      return Object.values(UPGRADES).some(upgrade =>
        upgrade.available &&
        Object.entries(upgrade.cost).every(([resource, amount]) => state[resource] >= amount) &&
        !state.upgrades[upgrade.id]
      );
    }
  },
  {
    id: 'low_resources',
    message: "Your resources are running low. Remember to balance resource gathering with other activities!",
    trigger: state => {
      const lowResources = state.food < 10 || state.water < 10 || state.wood < 10;
      const currentTime = state.hour + (state.day - 1) * 24;
      const cooldownPassed = currentTime - (state.lastLowResourceWarning || 0) >= 48;
      return lowResources && cooldownPassed;
    }
  },
  {
    id: 'first_module',
    message: "You've unlocked a new module! Explore its features to expand your survival options.",
    trigger: state => Object.keys(state.upgrades).length === 1
  },
  {
    id: 'party_management',
    message: "As your party grows, manage their energy and health carefully. Assign tasks wisely!",
    trigger: state => state.party.length > 3
  },
  {
    id: 'farming_intro',
    message: "You've unlocked Farming! Plant crops to secure a sustainable food source.",
    trigger: state => state.upgrades.farming && !state.shownTutorials.includes('farming_intro')
  },
  {
    id: 'well_intro',
    message: "The Well is now available! It provides a steady source of water over time.",
    trigger: state => state.upgrades.well && !state.shownTutorials.includes('well_intro')
  },
  {
    id: 'technology_intro',
    message: "You've unlocked the Technology system! Unlike upgrades which apply immediately, technologies require time to research but provide powerful benefits. Use your knowledge points wisely!",
    trigger: state => {
      const techModuleUnlocked = document.getElementById('technology-module') &&
        !document.getElementById('technology-module').classList.contains('mystery');
      return techModuleUnlocked && !state.shownTutorials?.includes('technology_intro');
    }
  },
  {
    id: 'hunting_intro',
    message: "You've built the Hunting Lodge! Hunt animals for food and other resources.",
    trigger: state => state.upgrades.huntingLodge && !state.shownTutorials.includes('hunting_intro')
  },
  {
    id: 'lumber_mill_intro',
    message: "The Lumber Mill is operational! Manage tree growth for a steady wood supply.",
    trigger: state => state.upgrades.lumberMill && !state.shownTutorials.includes('lumber_mill_intro')
  },
  {
    id: 'watchtower_intro',
    message: "The Watchtower is built! Use it to send rescue missions and potentially find new survivors.",
    trigger: state => state.upgrades.watchtower && !state.shownTutorials.includes('watchtower_intro')
  },
  {
    id: 'resource_balance',
    message: "Maintaining a balance of resources is crucial. Don't focus too much on one resource!",
    trigger: state => {
      const total = state.food + state.water + state.wood;
      return total > 300 && (state.food < 50 || state.water < 50 || state.wood < 50);
    }
  },
  {
    id: 'first_achievement',
    message: "You've earned your first achievement! Check the Achievements panel to see your progress.",
    trigger: state => Object.values(state.achievements).some(achieved => achieved)
  },
  {
    id: 'energy_management',
    message: "Keep an eye on your party's energy levels. Resting is important for maintaining productivity!",
    trigger: state => state.party.some(member => member.energy < 30)
  },
  {
    id: 'upgrade_strategy',
    message: "Consider your upgrade choices carefully. Some upgrades unlock new features, while others improve existing ones.",
    trigger: state => Object.keys(state.upgrades).length === 3
  },
  {
    id: 'random_events',
    message: "Random events can occur at any time. Be prepared to adapt your strategy!",
    trigger: state => state.day >= 5 && !state.shownTutorials.includes('random_events')
  },
  {
    id: 'long_term_planning',
    message: "As you progress, think about long-term sustainability. Invest in upgrades that provide passive benefits.",
    trigger: state => state.day >= 10 && !state.shownTutorials.includes('long_term_planning')
  },
  {
    id: 'automation_hint',
    message: "Look for ways to automate resource gathering. This will free up time for more strategic decisions.",
    trigger: state => Object.keys(state.upgrades).length >= 5 && !state.shownTutorials.includes('automation_hint')
  },
  {
    id: 'party_size_management',
    message: "A larger party can gather more resources, but also consumes more. Find the right balance for your strategy.",
    trigger: state => state.party.length >= 7 && !state.shownTutorials.includes('party_size_management')
  },
  {
    id: 'advanced_upgrades',
    message: "Advanced upgrades are now available! These can significantly boost your efficiency and survival chances.",
    trigger: state => state.upgrades.advancedFarming || state.upgrades.waterPurification
  },
  {
    id: 'crisis_management',
    message: "In times of crisis, prioritize immediate survival needs. You can always rebuild once the situation stabilizes.",
    trigger: state => (state.food < 5 || state.water < 5) && state.day > 15
  }
];

let shownTutorials = new Set();

export function checkTutorials() {
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  TUTORIAL_MESSAGES.forEach(tutorial => {
    if (!shownTutorials.has(tutorial.id) && tutorial.trigger(gameState)) {
      addLogEntry(tutorial.message, 'tutorial');
      shownTutorials.add(tutorial.id);
      if (tutorial.id === 'low_resources') {
        gameState.lastLowResourceWarning = currentTime;
      }
    }
  });
}

export function initializeTutorials() {
  if (!gameState.shownTutorials) {
    gameState.shownTutorials = [];
  }
  if (!gameState.hasOwnProperty('lastLowResourceWarning')) {
    gameState.lastLowResourceWarning = 0;
  }
  shownTutorials = new Set();
}

export function saveTutorialState() {
  gameState.shownTutorials = Array.from(shownTutorials);
}


================================================
FILE: javascript/upgrades.js
================================================
import { gameState, UPGRADES } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';
import { saveGameState } from './storage.js';
import { initializeFarming } from './farming.js';
import { initializeHunting } from './hunting.js';
import { initializeAutomatedFeeding, initializeWaterPurificationSystem, initializeComfortableSleepingQuarters, initializeFoodGatheringDrone, initializeWaterGatheringDrone, initializeWoodGatheringDrone } from './automation.js';
import { initializeWell } from './well.js';
import { initializeLumberMill } from './lumbermill.js';
import { initializeWatchtower } from './watchtower.js';
import { applyAdvancedFarmingEffects } from './farming.js';
import { getWoodCostReduction } from './specializations.js';
import { initializeMedicalTent } from './medicaltent.js';

/**
 * Buys an upgrade if the player can afford it.
 * @param {string} upgradeId - The ID of the upgrade to buy.
 */
export function buyUpgrade(upgradeId) {
  const upgrade = UPGRADES[upgradeId];
  if (!upgrade || gameState.upgrades[upgradeId]) return;

  // Calculate costs with builder discount applied to wood
  const adjustedCosts = {};
  for (const [resource, amount] of Object.entries(upgrade.cost)) {
    if (resource === 'wood') {
      // Find the best builder in the party
      const bestBuilder = findBestBuilder();
      const woodCostReduction = bestBuilder ? getWoodCostReduction(bestBuilder) : 1;
      adjustedCosts[resource] = Math.floor(amount * woodCostReduction);
    } else {
      adjustedCosts[resource] = amount;
    }
  }

  let canAfford = true;
  for (const [resource, amount] of Object.entries(adjustedCosts)) {
    if (gameState[resource] < amount) {
      canAfford = false;
      break;
    }
  }

  if (canAfford) {
    for (const [resource, amount] of Object.entries(adjustedCosts)) {
      gameState[resource] -= amount;
    }
    gameState.upgrades[upgradeId] = true;

    // Log the upgrade purchase with discount information if applicable
    if (adjustedCosts.wood !== upgrade.cost.wood) {
      addLogEntry(`Unlocked upgrade: ${upgrade.name} (Builder discount applied: ${upgrade.cost.wood - adjustedCosts.wood} wood saved)`, 'success');
    } else {
      addLogEntry(`Unlocked upgrade: ${upgrade.name}`, 'success');
    }

    applyUpgradeEffects(upgradeId);
    checkPrerequisites(upgradeId);
    updateGameState();
    updateUpgradesUI();
    saveGameState(); // Add this line to save the game state after buying an upgrade
  } else {
    addLogEntry(`Cannot afford upgrade: ${upgrade.name}`, 'error');
  }
}

/**
 * Finds the party member with the builder specialization who provides the best wood cost reduction.
 * @returns {Object|null} The best builder party member, or null if none found.
 */
function findBestBuilder() {
  if (!gameState.party) return null;

  return gameState.party.reduce((bestBuilder, member) => {
    if (member.specialization === 'builder' && !member.isDead) {
      if (!bestBuilder) return member;
    }
    return bestBuilder;
  }, null);
}

/**
 * Applies the effects of an upgrade.
 * @param {string} upgradeId - The ID of the upgrade to apply.
 */
export function applyUpgradeEffects(upgradeId) {
  switch (upgradeId) {
    case 'farming':
      unlockSecondaryModule('farming-module');
      initializeFarming();
      break;
    case 'well':
      unlockSecondaryModule('well-module');
      initializeWell();
      break;
    case 'huntingLodge':
      unlockSecondaryModule('hunting-module');
      initializeHunting();
      break;
    case 'advancedFarming':
      applyAdvancedFarmingEffects();
      break;
    case 'waterPurification':
      applyWaterPurificationEffects();
      break;
    case 'toolWorkshop':
      applyToolWorkshopEffects();
      break;
    case 'medicalTent':
      initializeMedicalTent();
      break;
    case 'lumberMill':
      unlockSecondaryModule('lumber-mill-module');
      initializeLumberMill();
      break;
    case 'watchtower':
      unlockSecondaryModule('watchtower-module');
      initializeWatchtower();
      break;
    case 'automatedFeeding':
      initializeAutomatedFeeding();
      break;
    case 'waterPurificationSystem':
      initializeWaterPurificationSystem();
      break;
    case 'comfortableSleepingQuarters':
      initializeComfortableSleepingQuarters();
      break;
    case 'foodGatheringDrone':
      initializeFoodGatheringDrone();
      break;
    case 'waterGatheringDrone':
      initializeWaterGatheringDrone();
      break;
    case 'woodGatheringDrone':
      initializeWoodGatheringDrone();
      break;
    case 'specializations':
      initializeSpecializations();
      break;
    default:
      console.warn(`No effects implemented for upgrade: ${upgradeId}`);
  }
}

/**
 * Checks and updates the availability of upgrades.
 */
export function checkUpgradeAvailability() {
  if (!gameState.upgrades) {
    gameState.upgrades = {};
  }

  for (const [upgradeId, upgrade] of Object.entries(UPGRADES)) {
    if (!gameState.upgrades[upgradeId]) {
      let canAfford = true;
      for (const [resource, amount] of Object.entries(upgrade.cost)) {
        if (gameState[resource] < amount) {
          canAfford = false;
          break;
        }
      }

      if (!upgrade.available) {
        if ((upgrade.prerequisite && gameState.upgrades[upgrade.prerequisite]) || !upgrade.prerequisite) {
          upgrade.available = canAfford;
          if (canAfford) {
            addLogEntry(`New upgrade available: ${upgrade.name}`, 'info');
          }
        }
      }
    } else {
      upgrade.available = false; // Set to false if already purchased
    }
  }
  updateUpgradesUI();
}

/**
 * Updates the upgrades UI.
 */
export function updateUpgradesUI() {
  const upgradesContainer = document.getElementById('upgrades');
  if (!upgradesContainer) return;

  upgradesContainer.innerHTML = '';

  for (const [upgradeId, upgrade] of Object.entries(UPGRADES)) {
    if (upgrade.available || gameState.upgrades[upgradeId]) {
      const upgradeButton = document.createElement('button');
      upgradeButton.className = 'upgrade-button';
      upgradeButton.dataset.upgradeId = upgradeId;

      // Calculate costs with builder discount applied to wood
      const adjustedCosts = {};
      let builderDiscountApplied = false;
      let originalWoodCost = 0;
      let discountedWoodCost = 0;

      for (const [resource, amount] of Object.entries(upgrade.cost)) {
        if (resource === 'wood') {
          // Find the best builder in the party
          const bestBuilder = findBestBuilder();
          const woodCostReduction = bestBuilder ? getWoodCostReduction(bestBuilder) : 1;

          if (woodCostReduction < 1) {
            builderDiscountApplied = true;
            originalWoodCost = amount;
            discountedWoodCost = Math.floor(amount * woodCostReduction);
            adjustedCosts[resource] = discountedWoodCost;
          } else {
            adjustedCosts[resource] = amount;
          }
        } else {
          adjustedCosts[resource] = amount;
        }
      }

      let canAfford = true;
      for (const [resource, amount] of Object.entries(adjustedCosts)) {
        if (gameState[resource] < amount) {
          canAfford = false;
          break;
        }
      }

      if (gameState.upgrades[upgradeId]) {
        upgradeButton.classList.add('purchased');
      } else if (!canAfford) {
        upgradeButton.classList.add('cannot-afford');
      } else {
        upgradeButton.classList.add('available');
      }

      upgradeButton.innerHTML = `
        <div class="upgrade-name">
          <span class="name">${upgrade.name}</span>
          <span class="cost">
            ${Object.entries(upgrade.cost).map(([resource, amount]) => {
        if (resource === 'wood' && builderDiscountApplied) {
          return `
                  <span class="discounted-cost">
                    <span class="original-cost">${originalWoodCost}</span>
                    <span class="discount-arrow">→</span>
                    ${discountedWoodCost}
                  </span>
                  <i data-lucide="${getResourceIcon(resource)}" class="icon ${getResourceColor(resource)}"></i>
                `;
        } else {
          return `
                  ${amount} <i data-lucide="${getResourceIcon(resource)}" class="icon ${getResourceColor(resource)}"></i>
                `;
        }
      }).join('')}
          </span>
        </div>
        <div class="upgrade-effect">${upgrade.effect}</div>
        ${builderDiscountApplied ? `<div class="builder-discount">Builder discount applied: ${Math.round((1 - discountedWoodCost / originalWoodCost) * 100)}%</div>` : ''}
      `;

      if (!gameState.upgrades[upgradeId]) {
        upgradeButton.addEventListener('click', () => buyUpgrade(upgradeId));
      }

      upgradesContainer.appendChild(upgradeButton);
    }
  }

  // Refresh Lucide icons
  if (typeof lucide !== 'undefined' && typeof lucide.createIcons === 'function') {
    lucide.createIcons();
  }
}

/**
 * Gets the appropriate icon for a resource.
 * @param {string} resource - The resource type.
 * @returns {string} The icon name for the resource.
 */
function getResourceIcon(resource) {
  switch (resource) {
    case 'food': return 'beef';
    case 'water': return 'droplet';
    case 'wood': return 'tree-pine';
    case 'knowledgePoints': return 'book';
    default: return 'circle';
  }
}

/**
 * Gets the appropriate color class for a resource icon.
 * @param {string} resource - The resource type.
 * @returns {string} The color class for the resource icon.
 */
function getResourceColor(resource) {
  switch (resource) {
    case 'food': return 'dark-yellow';
    case 'water': return 'blue';
    case 'wood': return 'green';
    case 'knowledgePoints': return 'magenta';
    default: return '';
  }
}

/**
 * Initializes the upgrades module.
 */
export function initializeUpgrades() {
  if (!gameState.upgrades) {
    gameState.upgrades = {};
  }

  // Check and update the availability of upgrades based on the saved state
  for (const [upgradeId, upgrade] of Object.entries(UPGRADES)) {
    if (gameState.upgrades[upgradeId]) {
      upgrade.available = false; // Set to false if already purchased
    } else if (upgrade.prerequisite) {
      upgrade.available = gameState.upgrades[upgrade.prerequisite] || false;
    } else {
      upgrade.available = true; // Set to true for upgrades without prerequisites
    }
  }

  updateUpgradesUI();
}

function checkPrerequisites(purchasedUpgradeId) {
  for (const [upgradeId, upgrade] of Object.entries(UPGRADES)) {
    if (!gameState.upgrades[upgradeId] && upgrade.prerequisite === purchasedUpgradeId) {
      upgrade.available = true;
      addLogEntry(`New upgrade available: ${upgrade.name}`, 'info');
    }
  }
}

/**
 * Unlocks a secondary module by removing its mystery state.
 * @param {string} moduleId - The ID of the module to unlock.
 */
export function unlockSecondaryModule(moduleId) {
  const module = document.getElementById(moduleId);
  if (module && module.classList.contains('mystery')) {
    module.classList.remove('mystery');
    module.innerHTML = `
      <h2><i data-lucide="${getModuleIcon(moduleId)}" class="icon-dark"></i> ${getModuleTitle(moduleId)}</h2>
      <section class="module-content"></section>
    `;
    createLucideIcons();
    addLogEntry(`Unlocked new module: ${getModuleTitle(moduleId)}`, 'success');
  }
}

function getModuleIcon(moduleId) {
  switch (moduleId) {
    case 'farming-module': return 'sprout';
    case 'well-module': return 'droplet';
    case 'hunting-module': return 'target';
    case 'lumber-mill-module': return 'axe';
    case 'watchtower-module': return 'eye';
    default: return 'circle-help';
  }
}

function getModuleTitle(moduleId) {
  return moduleId.replace('-module', '').split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

/**
 * Applies the effects of the Water Purification System upgrade.
 */
function applyWaterPurificationEffects() {
  gameState.waterPurificationActive = true;
  addLogEntry('Water Purification System activated: Water consumption reduced by 20% for all activities.', 'success');
}

function applyToolWorkshopEffects() {
  gameState.resourceEfficiency = 1.25; // 25% increase in resource gathering efficiency
  addLogEntry('Tool Workshop built. Resource gathering efficiency increased by 25%!', 'success');
}

/**
 * Initializes the specialization system after the upgrade is purchased.
 */
function initializeSpecializations() {
  addLogEntry('Specialization Training complete! Party members can now specialize in different roles.', 'success');
  // Force update of party display to show specialization options
  import('./party.js').then(partyModule => {
    partyModule.updatePartyDisplay();
  });
}


================================================
FILE: javascript/utils.js
================================================
/**
 * Creates Lucide icons if the library is available.
 * This function checks for the presence of the Lucide library and its createIcons method.
 * If available, it creates the icons. Otherwise, it logs a warning.
 */
export function createLucideIcons() {
  // Check if Lucide library and createIcons function are available
  if (typeof lucide !== 'undefined' && typeof lucide.createIcons === 'function') {
    // Create icons using Lucide
    lucide.createIcons();
  } else {
    // Log a warning if Lucide is not available
    console.warn('Lucide library not loaded or createIcons function not available');
  }
}

import { saveCollapseState, loadCollapseState } from './storage.js';

export function initializeCollapsibles() {
  const collapsibles = document.querySelectorAll('.collapsible');

  collapsibles.forEach(collapsible => {
    const moduleId = collapsible.closest('[id]').id;
    const isCollapsed = loadCollapseState(moduleId);

    if (isCollapsed) {
      collapsible.classList.add('collapsed');
      collapsible.nextElementSibling.classList.add('collapsed');
    }

    collapsible.addEventListener('click', () => {
      collapsible.classList.toggle('collapsed');
      const content = collapsible.nextElementSibling;
      content.classList.toggle('collapsed');

      const newCollapseState = collapsible.classList.contains('collapsed');
      saveCollapseState(moduleId, newCollapseState);
    });
  });
}


================================================
FILE: javascript/watchtower.js
================================================
/**
 * Watchtower Module
 * Handles rescue missions and related functionality in the game.
 */

import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';
import { PartyMember } from './party.js';

// Constants for rescue mission configuration
const RESCUE_MISSION_INTERVAL = 1; // Days between rescue missions
const RESCUE_MISSION_TYPES = {
  easy: { risk: 0.1, resourceCost: { food: 20, water: 20 }, duration: 24 },
  medium: { risk: 0.3, resourceCost: { food: 40, water: 40 }, duration: 48 },
  hard: { risk: 0.5, resourceCost: { food: 60, water: 60 }, duration: 72 }
};

/**
 * Initializes the watchtower module in the game state.
 */
export function initializeWatchtower() {
  if (!gameState.watchtower) {
    gameState.watchtower = {
      lastRescueMissionDay: 0,
      rescueMissionAvailable: true,
      rescueMission: null
    };
  }
  updateWatchtowerUI();
}

/**
 * Initiates a rescue mission with the specified difficulty.
 * @param {string} difficulty - The difficulty level of the mission ('easy', 'medium', or 'hard').
 */
export function initiateRescueMission(difficulty) {
  const mission = RESCUE_MISSION_TYPES[difficulty];

  if (gameState.food < mission.resourceCost.food || gameState.water < mission.resourceCost.water) {
    addLogEntry("Not enough resources for this rescue mission.", 'error');
    return;
  }

  // Deduct resources and set up the mission
  gameState.food -= mission.resourceCost.food;
  gameState.water -= mission.resourceCost.water;
  const currentTime = gameState.hour + (gameState.day - 1) * 24;
  gameState.watchtower.rescueMission = {
    difficulty,
    startTime: currentTime,
    endTime: currentTime + mission.duration
  };

  addLogEntry(`A ${difficulty} rescue mission has been initiated. It will take ${mission.duration} hours.`, 'info');
  gameState.watchtower.rescueMissionAvailable = false;
  updateWatchtowerUI();
  updateGameState();
}

/**
 * Checks if an ongoing rescue mission has completed.
 */
export function checkRescueMission() {
  if (gameState.watchtower.rescueMission) {
    const currentTime = gameState.hour + (gameState.day - 1) * 24;
    if (currentTime >= gameState.watchtower.rescueMission.endTime) {
      completeRescueMission();
    }
  }
}

/**
 * Completes the current rescue mission and processes its outcome.
 */
function completeRescueMission() {
  const { difficulty } = gameState.watchtower.rescueMission;
  const missionType = RESCUE_MISSION_TYPES[difficulty];
  const success = Math.random() > missionType.risk;

  success ? handleSuccessfulRescue(difficulty) : handleFailedRescue();

  // Reset mission state
  gameState.watchtower.rescueMission = null;
  gameState.watchtower.rescueMissionAvailable = false;
  gameState.watchtower.lastRescueMissionDay = gameState.day;

  updateWatchtowerUI();
  updateGameState();
}

/**
 * Handles the outcome of a successful rescue mission.
 * @param {string} difficulty - The difficulty of the completed mission.
 */
function handleSuccessfulRescue(difficulty) {
  const bonusResources = {
    food: Math.floor(Math.random() * 50) + 10,
    water: Math.floor(Math.random() * 50) + 10,
    wood: Math.floor(Math.random() * 30) + 5
  };

  // Add bonus resources to game state
  Object.entries(bonusResources).forEach(([resource, amount]) => {
    gameState[resource] += amount;
    gameState.totalResourcesGathered[resource] += amount;
  });

  // Chance to add a new survivor
  if (Math.random() > 0.5) {
    const newSurvivor = new PartyMember();
    gameState.party.push(newSurvivor);
    addLogEntry(`Rescue mission successful! ${newSurvivor.name} has joined your party. They brought some supplies: ${bonusResources.food} food, ${bonusResources.water} water, and ${bonusResources.wood} wood.`, 'success');
  } else {
    addLogEntry(`Rescue mission successful! No survivors found, but the team recovered some supplies: ${bonusResources.food} food, ${bonusResources.water} water, and ${bonusResources.wood} wood.`, 'success');
  }
}

/**
 * Handles the outcome of a failed rescue mission.
 */
function handleFailedRescue() {
  if (Math.random() < 0.5 && gameState.party.length > 0) {
    const injuredPerson = gameState.party[Math.floor(Math.random() * gameState.party.length)];
    injuredPerson.health = Math.max(10, injuredPerson.health - 40);
    addLogEntry(`Rescue mission failed. ${injuredPerson.name} was injured during the attempt.`, 'error');
  } else {
    addLogEntry("Rescue mission failed. The team returned empty-handed.", 'error');
  }
}

/**
 * Updates the Watchtower UI based on the current game state.
 */
export function updateWatchtowerUI() {
  const watchtowerModule = document.getElementById('watchtower-module');
  if (!watchtowerModule || !gameState.upgrades.watchtower) return;

  watchtowerModule.classList.remove('hidden');
  const currentTime = gameState.hour + (gameState.day - 1) * 24;

  let content = '';
  if (gameState.watchtower.rescueMission) {
    content = generateMissionProgressUI(currentTime);
  } else if (gameState.watchtower.rescueMissionAvailable) {
    content = generateMissionOptionsUI();
  } else {
    content = generateCountdownUI(currentTime);
  }

  watchtowerModule.innerHTML = `
    <h2><i data-lucide="binoculars" class="icon-dark"></i> Watchtower</h2>
    ${content}
  `;

  createLucideIcons();
}

/**
 * Generates UI for ongoing mission progress.
 * @param {number} currentTime - The current game time.
 * @returns {string} HTML string for mission progress UI.
 */
function generateMissionProgressUI(currentTime) {
  const { difficulty, endTime } = gameState.watchtower.rescueMission;
  const remainingTime = endTime - currentTime;
  const remainingDays = Math.floor(remainingTime / 24);
  const remainingHours = remainingTime % 24;

  return `
    <div class="mission-progress">
      <p class="mission-status">Rescue mission in progress:</p>
      <p class="mission-difficulty">${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)} Mission</p>
      <p class="time-remaining">Time remaining: <span>${remainingDays}d ${remainingHours}h</span></p>
    </div>
  `;
}

/**
 * Generates UI for available mission options.
 * @returns {string} HTML string for mission options UI.
 */
function generateMissionOptionsUI() {
  return `
    <p class="mission-available">A rescue mission is available!</p>
    <div class="mission-options">
      ${Object.entries(RESCUE_MISSION_TYPES).map(([difficulty, { duration, risk, resourceCost }]) => `
        <button onclick="window.initiateRescueMission('${difficulty}')" class="${difficulty}-mission">
          <div>${difficulty.charAt(0).toUpperCase() + difficulty.slice(1)}</div>
          <span>(${duration / 24}d, ${risk < 0.3 ? 'Low' : risk < 0.5 ? 'Moderate' : 'High'} Risk, Cost: ${resourceCost.food} <i data-lucide="beef"></i>, ${resourceCost.water} <i data-lucide="droplet"></i>)</span>
        </button>
      `).join('')}
    </div>
  `;
}

/**
 * Generates UI for countdown to next available mission.
 * @param {number} currentTime - The current game time.
 * @returns {string} HTML string for countdown UI.
 */
function generateCountdownUI(currentTime) {
  const lastMissionTime = gameState.watchtower.lastRescueMissionDay * 24;
  const timeSinceLastMission = currentTime - lastMissionTime;
  const missionInterval = RESCUE_MISSION_INTERVAL * 24;
  const timeUntilNextMission = Math.max(
    0,
    missionInterval - timeSinceLastMission
  );
  const daysUntilNextMission = Math.floor(timeUntilNextMission / 24);
  const hoursUntilNextMission = Math.floor(timeUntilNextMission % 24);

  if (timeUntilNextMission === 0) {
    gameState.watchtower.rescueMissionAvailable = true;
    return generateMissionOptionsUI();
  }

  return `<p class="countdown">Next mission in: ${daysUntilNextMission}d ${hoursUntilNextMission}h</p>`;
}

// Expose the initiateRescueMission function to the global scope
window.initiateRescueMission = initiateRescueMission;


================================================
FILE: javascript/well.js
================================================
/**
 * Well Module
 * Handles the functionality of the well in the game, including water generation and collection.
 */

import { gameState } from './settings.js';
import { updateGameState } from './game.js';
import { addLogEntry } from './log.js';
import { createLucideIcons } from './utils.js';

/**
 * Initializes the well in the game state and updates the UI.
 */
export function initializeWell() {
  if (!gameState.well) {
    gameState.well = {
      capacity: 100,
      current: 0,
      fillRate: 1
    };
  }
  updateWellUI();
}

/**
 * Collects water from the well, updates game state, and logs the action.
 */
export function collectWellWater() {
  const amountCollected = Math.min(gameState.well.current, gameState.well.capacity);
  gameState.water += amountCollected;
  gameState.well.current = 0;
  gameState.totalWellWaterCollected += amountCollected;
  gameState.totalActions++;

  addLogEntry(`Collected ${amountCollected} water from the well.`, 'success');
  updateWellUI();
  updateGameState();
}

/**
 * Generates water in the well based on the fill rate and available capacity.
 */
export function generateWellWater() {
  if (gameState.upgrades.well) {
    const generated = Math.min(gameState.well.fillRate, gameState.well.capacity - gameState.well.current);
    gameState.well.current += generated;
    updateWellUI();
  }
}

/**
 * Updates the well UI with current water levels and collection button.
 */
function updateWellUI() {
  const wellModule = document.getElementById('well-module');
  if (!wellModule) return;

  const percentage = (gameState.well.current / gameState.well.capacity) * 100;

  wellModule.innerHTML = `
    <h2><i data-lucide="glass-water" class="icon-dark"></i> Well</h2>
    <div class="well-container">
      <div id="well-progress">
        <span id="well-level">${Math.floor(gameState.well.current)}/${gameState.well.capacity}</span>
        <div id="well-water" style="width: ${percentage}%;"></div>
      </div>
      <button id="collect-water-btn">Collect Water</button>
    </div>
  `;

  // Add event listener to the button
  document.getElementById('collect-water-btn').addEventListener('click', collectWellWater);

  createLucideIcons();
}

// No need to expose collectWellWater to the global scope anymore


================================================
FILE: stylesheets/achievements.css
================================================
#achievements-module {
  #achievements {
    display: grid;
    grid-template-columns: 1fr;
    border-top: var(--border-thickness) solid var(--text-color);

    @media (min-width: 768px) {
      grid-template-columns: 1fr 1fr;
    }
  }
}

#achievements .achievement-item {
  padding: 0.75rem;
  border-bottom: var(--border-thickness) solid var(--text-color);
  display: flex;
  align-items: center;

  &:nth-child(even) {
    border-left: var(--border-thickness) solid var(--text-color);
  }

  &:last-child,
  &:nth-last-child(2):nth-child(odd) {
    border-bottom: none;
  }
}

.achievement-item {
  .achievement-icon {
    margin-right: 0.5rem;
  }

  .achievement-info {
    flex: 1;
  }

  .achievement-name {
    font-weight: 700;
  }

  .achievement-description {
    font-size: 0.8em;
  }
}

.achievement-unlocked {
  background-color: var(--green);
}

.achievement-locked {

  .achievement-name,
  .achievement-description {
    opacity: 0.5;
  }
}


================================================
FILE: stylesheets/actions.css
================================================
#actions-module {
  display: flex;
  gap: 0;
  border: var(--border-thickness) solid var(--text-color);
  border-top: 0;
  margin-bottom: 1em;
}

.action-button {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1em;
  border: 0;
  border-right: var(--border-thickness) solid var(--text-color);
  padding: 1em;
  margin: 0;
  flex: 1;
  transition: background-color 0.3s ease;
  background-color: var(--background-color);
  color: var(--text-color);
  cursor: pointer;
}

.action-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  background-color: var(--background-color);
  color: var(--text-color);
}

.action-button:disabled:hover {
  background-color: var(--background-color);
  color: var(--text-color);
}

.action-button:last-child {
  border-right: 0;
}

.action-button .lucide {
  width: 2em;
  height: 2em;
}

.action-button span {
  font-weight: 700;
  text-transform: uppercase;
}

.action-button:hover {
  background-color: var(--text-color);
  color: var(--background-color);
}

@media (max-width: 100ch) {
  #actions-module {
    flex-direction: column;
  }

  .action-buttons {
    flex-direction: column;
  }

  .action-button {
    border-right: 0;
    border-bottom: var(--border-thickness) solid var(--text-color);
  }

  .action-button:last-child {
    border-bottom: 0;
  }
}


================================================
FILE: stylesheets/base.css
================================================
body {
  color: var(--text-color);
  background-color: var(--background-color);
  margin: 0;
}

/* Links */
:where(a:not([class]):not(:has(img))) {
  color: var(--link-color, var(--color-link));

  @media (any-hover: hover) {
    &:where(:not(:active):hover) {
      --hover-filter: brightness(1.3);

      filter: var(--hover-filter);
    }
  }
}

::selection {
  background-color: var(--dark-red);
}


================================================
FILE: stylesheets/buttons.css
================================================
button {
  font-family: var(--font-family);
  background-color: var(--background-color);
  color: var(--text-color);
  border: var(--border-thickness) solid var(--text-color);
  padding: 0.5rem 1rem;
  margin: 0.5rem 0;
  cursor: pointer;
  transition: background-color 0.3s;
}

button:hover {
  background-color: var(--text-color);
  color: var(--background-color);
}


================================================
FILE: stylesheets/contentment.css
================================================
/* 
 * Contentment System Styles
 * Styles for the contentment system UI elements
 */

.contentment-display {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 0 1em;
  border-right: var(--border-thickness) solid var(--text-color);
  min-width: 60px;
}

.contentment-display i {
  font-size: 1.5rem;
  margin-bottom: 0.2rem;
}

.contentment-display span {
  font-size: 0.8rem;
  font-weight: 600;
  text-align: center;
}

/* Responsive styles */
@media (max-width: 1100px) {
  .contentment-display {
    border-left: none;
    border-top: var(--border-thickness) solid var(--text-color);
    width: 100%;
    padding: 0.5em 1em;
    flex-direction: row;
    justify-content: flex-start;
    gap: 1em;
  }

  .contentment-display i {
    margin-bottom: 0;
  }

  .contentment-display span {
    margin-bottom: 0;
    margin-right: 1em;
  }
}


================================================
FILE: stylesheets/core.css
================================================
@import "settings.css";
@import "reset.css";
@import "utils.css";
@import "typography.css";
@import "buttons.css";
@import "base.css";
@import "start.css";
@import "icons.css";
@import "shell.css";
@import "party.css";
@import "actions.css";
@import "log.css";
@import "upgrades.css";
@import "modules.css";
@import "farming.css";
@import "well.css";
@import "hunting.css";
@import "lumbermill.css";
@import "achievements.css";
@import "watchtower.css";
@import "technologies.css";
@import "contentment.css";
@import "shortcuts.css";
@import "modal.css";
@import "gameover.css";


================================================
FILE: stylesheets/farming.css
================================================
#farming-module {
  .crop-picker {
    display: flex;
    align-items: stretch;
    justify-content: stretch;
    border-bottom: var(--border-thickness) solid var(--text-color);

    button {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      border: 0;
      padding: 0.5em;
      font-size: 0.8em;

      &:not(:first-child) {
        border-left: var(--border-thickness) solid var(--text-color);
      }

      &.active {
        background-color: var(--green);
      }

      .lucide:first-child {
        width: 1.75em;
        height: 1.75em;
        margin-right: 0.5em;
      }

      .lucide:last-child {
        width: 1em;
        height: 1em;
      }
    }
  }

  .water-all-button {
    display: flex;
    align-items: center;
    justify-content: center;
    border-bottom: var(--border-thickness) solid var(--text-color);

    button {
      width: 100%;
      margin: 0;
      border: 0;
      display: flex;
      flex-direction: column;
      padding: 0.5em;
      align-items: center;
      justify-content: space-between;

      div {
        display: flex;
        align-items: center;
        gap: 0.2em;

        .lucide {
          width: 1em;
          height: 1em;
        }
      }

      span {
        font-size: 0.8em;
      }
    }
  }

  .icon-wheat {
    color: var(--light-yellow);
  }

  .icon-carrot {
    color: var(--dark-yellow);
  }

  .icon-bean {
    color: var(--dark-red);
  }

  #farming-grid {
    margin: 1rem;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    border: var(--border-thickness) solid var(--text-color);

    .plot-cell {
      aspect-ratio: 1 / 1;
      border-right: 1px solid white;
      border-bottom: 1px solid white;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;

      .lucide {
        width: 2em;
        height: 2em;
      }

      &.empty-plot {
        background-color: var(--background-color-alt);
      }

      &.empty-plot:hover,
      &.ready-to-harvest:hover {
        background-color: var(--green);
        cursor: pointer;
      }

      /* Growth stage styles */
      &.just-planted {
        background-color: var(--background-color-alt);
        opacity: 0.7;
      }

      &.quarter-grown {
        background-color: rgba(var(--green-rgb), 0.25);
      }

      &.half-grown {
        background-color: rgba(var(--green-rgb), 0.5);
      }

      &.almost-ready {
        background-color: rgba(var(--green-rgb), 0.75);
      }

      /* Growth progress indicator */
      .growth-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        font-size: 0.7em;
        text-align: center;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 2px 0;
      }

      &.growing {
        &:hover {
          background-color: transparent;
          cursor: default;
        }
      }

      &.ready-to-harvest {
        .lucide {
          color: var(--green);
        }

        &:hover {
          .lucide {
            color: var(--background-color);
          }

          background-color: var(--green);
        }
      }
    }
  }
}


================================================
FILE: stylesheets/gameover.css
================================================
#game_over_screen {
  text-align: left;
  padding: 0 2rem;
  margin: 0 auto;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  max-width: 600px;

  .splash_screen {
    border: var(--border-thickness) solid var(--text-color);
  }

  .splash_header {
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    font-size: 3rem;

    .icon-large {
      padding: 1rem;
      font-size: 2em;
      border-right: var(--border-thickness) solid var(--text-color);
    }

    div {
      padding-left: 1.5rem;
    }

    h1 {
      font-size: 2.75rem;
      font-weight: 700;
      margin: 0;
      line-height: 1em;
      letter-spacing: -0.03em;
      text-transform: uppercase;
    }

    p {
      font-size: 1.2rem;
      margin: 0;
    }
  }

  #game_stats {
    .numbers {
      border-bottom: var(--border-thickness) solid var(--text-color);
      display: flex;

      p {
        padding: 1rem;
        margin: 0;
        font-size: 1.2rem;
        font-weight: 700;
        text-transform: uppercase;
        border-right: var(--border-thickness) solid var(--text-color);
      }

      .resource-list {
        display: flex;
        gap: 1.5em;
        font-size: 1.5em;
        font-weight: 700;
        margin-left: 1rem;

        .resource {
          display: flex;
          align-items: center;
          gap: 0.2em;
        }
      }
    }

    .achievements {
      .achievement-list {
        display: grid;
        grid-template-columns: 1fr;
      }

      .achievement-item {
        padding: 0.75rem;
        border-bottom: var(--border-thickness) solid var(--text-color);

        &:nth-child(even) {
          border-left: var(--border-thickness) solid var(--text-color);
        }

        .achievement-name {
          font-weight: 700;
        }

        .achievement-description {
          font-size: 0.8em;
        }
      }
    }

    h2 {
      display: flex;
      text-transform: uppercase;
      font-size: 1.5rem;
      font-weight: 700;
      border-bottom: var(--border-thickness) solid var(--text-color);

      b {
        padding: 1rem;
        border-right: var(--border-thickness) solid var(--text-color);
      }

      .time {
        padding: 1rem;
        color: var(--dark-red);
      }
    }
  }

  button {
    width: 100%;
    padding: 1rem;
    font-size: 1.2rem;
    font-weight: 700;
    text-transform: uppercase;
    border: none;
    margin: 0;
    background-color: var(--dark-red);
    color: var(--text-color);
    cursor: pointer;
    transition: background-color 0.3s ease;

    &:hover {
      background-color: var(--text-color);
      color: var(--background-color);
    }
  }
}

@media (min-width: 768px) {
  #game_over_screen #game_stats .achievements .achievement-list {
    grid-template-columns: 1fr 1fr;
  }
}

@media (max-width: 100ch) {
  #game_over_screen {
    .splash_header {
      h1 {
        font-size: 1.8rem;
      }

      p {
        font-size: .9rem;
      }
    }

    #game_stats {
      .numbers p {
        font-size: 0.75rem;
      }

      h2 {
        font-size: 1rem;
      }
    }
  }
}

@media (max-width: 50ch) {
  #game_over_screen .splash_header h1 {
    font-size: 1.5rem;
  }
}


================================================
FILE: stylesheets/hunting.css
================================================
#hunting-module {
  #hunting-area {
    background-color: var(--green);
    height: 10rem;
    overflow: hidden;
    position: relative;
  }

  .wildlife {
    position: absolute;
    cursor: crosshair;
    transition: all 0.2s;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);

    .lucide {
      width: 2.25rem;
      height: 2.25rem;
    }
  }
}


================================================
FILE: stylesheets/icons.css
================================================
.icon {
  display: flex;
  align-items: center;
  justify-content: center;

  &.red,
  &.dark-red {
    color: var(--dark-red);
  }

  &.blue {
    color: var(--blue);
  }

  &.green {
    color: var(--green);
  }

  &.light-green {
    color: var(--light-green);
  }

  &.light-yellow {
    color: var(--light-yellow);
  }

  &.dark-yellow {
    color: var(--dark-yellow);
  }

  &.magenta {
    color: var(--magenta);
  }

  &.gutter-grey {
    color: var(--gutter-grey);
  }
}


================================================
FILE: stylesheets/log.css
================================================
#log-module {
  border: var(--border-thickness) solid var(--text-color);

  h2 {
    background-color: white;
    color: black;
    text-transform: uppercase;
    font-weight: 600;
    padding: 0.2em 0.5em;
    font-size: 0.8em;
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    gap: 0.5em;
    cursor: pointer;

    .lucide {
      width: 1.2em;
      height: 1.2em;
    }
  }

  .module-content {
    max-height: 400px;
    overflow-y: auto;
    transition: max-height 0.3s ease-out;

    &.collapsed {
      max-height: 0;
      overflow: hidden;
    }
  }
}

#log-content {
  max-height: 300px;
  overflow-y: auto;

  .log-entry {
    font-size: 0.8em;
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: stretch;

    &:last-child {
      border-bottom: none;
    }

    b {
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: center;
      border-right: var(--border-thickness) solid var(--text-color);
      padding: 0.5em;
      width: 4em;
      min-width: 4em;
      flex-shrink: 0;
    }

    span {
      padding: 0.5em;
    }

    &.info,
    &.neutral {
      background-color: var(--gutter-grey);
    }

    &.warning {
      background-color: var(--light-yellow);
    }

    &.negative,
    &.error {
      background-color: var(--dark-red);
    }

    &.positive,
    &.success {
      background-color: var(--green);
    }

    &.whisper {
      background-color: var(--magenta);
    }

    &.tutorial {
      background-color: var(--blue);
    }
  }
}


================================================
FILE: stylesheets/lumbermill.css
================================================
#lumber-mill-module {
  #lumber-mill-grid {
    margin: 1rem;
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    border: var(--border-thickness) solid var(--text-color);

    .tree-cell {
      aspect-ratio: 1 / 1;
      border-right: 1px solid white;
      border-bottom: 1px solid white;
      cursor: default;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;

      &:nth-child(5n) {
        border-right: none;
      }

      &:nth-last-child(-n+5) {
        border-bottom: none;
      }

      .growth-indicator {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        background-color: var(--green);
        transition: height 0.3s ease;
      }

      .lucide {
        width: 2em;
        height: 2em;
        position: relative;
        z-index: 1;
      }

      &.ready-to-harvest {
        .growth-indicator {
          background-color: var(--green);
        }

        &:hover {
          background-color: var(--green);
          cursor: pointer;

          .lucide {
            color: black;
          }
        }
      }
    }
  }
}


================================================
FILE: stylesheets/modal.css
================================================
.modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;

  &.hidden {
    display: none;
  }

  .modal-content {
    background: var(--background-color);
    border: var(--border-thickness) solid var(--text-color);
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    display: flex;
    flex-direction: column;
    
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem;
      border-bottom: var(--border-thickness) solid var(--text-color);
      flex-shrink: 0;

      h2 {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin: 0;
        font-size: 1.2rem;
      }

      .close-modal {
        padding: 0.5rem;
        border: none;
        background: none;
        cursor: pointer;
      }
    }

    .shortcuts-toggle {
      padding: 1rem;
      border-bottom: var(--border-thickness) solid var(--text-color);
      flex-shrink: 0;

      label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
    }

    .shortcuts-list {
      padding: 1rem;
      overflow-y: auto;

      h3 {
        margin: 0 0 0.5rem;
        font-size: 1rem;
      }

      .empty-state {
        color: var(--text-color-muted);
        font-style: italic;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        margin: 0 0 1.5rem;

        th, td {
          text-align: left;
          padding: 0.5rem;
          width: 33.33%;
        }

        th {
          font-weight: bold;
          border-bottom: var(--border-thickness) solid var(--text-color);
        }
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0 0 1.5rem;

        li {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          margin-bottom: 0.5rem;
        }
      }

      kbd {
        background: var(--text-color);
        color: var(--background-color);
        padding: 0.2rem 0.4rem;
        border-radius: 3px;
        font-size: 0.9em;
        min-width: 1.5em;
        text-align: center;
        display: inline-block;
      }
    }
  }
}

/* Hide shortcuts when toggled off */
body.hide-shortcuts .shortcut {
  display: none !important;
} 


================================================
FILE: stylesheets/modules.css
================================================
#game-modules {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

#main-modules {
  flex: 1;
  display: grid;
  gap: 1rem;
  align-self: flex-start;
}

#secondary-modules {
  column-count: 1;
  column-gap: 1rem;
}

#secondary-modules>section {
  break-inside: avoid;
  margin-bottom: 1rem;
}

#main-modules>section,
#secondary-modules>section {
  border: var(--border-thickness) solid var(--text-color);
  border-radius: var(--border-radius);
}

.module-content {
  transition: max-height 0.3s ease;
  overflow: hidden;
  max-height: 1000px;
  /* Adjust this value based on your content */
}

.module-content.collapsed {
  max-height: 0;
  display: none;
}

#game-modules h2 {
  background-color: white;
  color: black;
  text-transform: uppercase;
  font-weight: 700;
  padding: 0.2em 0.5em;
  font-size: 0.8em;
  border-bottom: var(--border-thickness) solid var(--text-color);
  display: flex;
  align-items: center;
  gap: 0.5em;
}

#game-modules h2 .lucide {
  width: 1.2em;
  height: 1.2em;
}

#game-modules h2.collapsible {
  cursor: pointer;
  user-select: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

#game-modules h2.collapsible .toggle-icon {
  transition: transform 0.3s ease;
}

#game-modules h2.collapsible.collapsed .toggle-icon {
  transform: rotate(180deg);
}

.mystery {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  border: var(--border-thickness) solid var(--text-color);
}

.mystery-content {
  padding: 1.5em;
  text-align: center;

  .icon {
    margin-bottom: 1em;

    .lucide {
      width: 3em;
      height: 3em;
    }
  }

  .title {
    font-size: 1.2em;
    font-weight: 700;
    margin-bottom: 0.5em;
    text-transform: uppercase;
  }

  .description {
    font-size: 0.9em;
    color: var(--text-color-alt);
    font-style: italic;
  }
}

@media (min-width: 100ch) {
  #game-modules {
    flex-direction: row;
    align-items: flex-start;
  }

  #main-modules {
    flex: 1;
    grid-template-columns: 1fr;
  }

  #secondary-modules {
    flex: 2;
    column-count: 2;
  }
}


================================================
FILE: stylesheets/party.css
================================================
#party-container {
  margin-top: 1em;
  margin-bottom: 1em;
  border: var(--border-thickness) solid var(--text-color);

  h2 {
    background-color: white;
    color: black;
    text-transform: uppercase;
    font-weight: 700;
    padding: 0.2em 0.5em;
    font-size: 0.8em;
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    gap: 0.5em;

    .lucide {
      width: 1.2em;
      height: 1.2em;
    }
  }

  #party-display {
    display: flex;
    flex-wrap: wrap;

    .person {
      flex: 1 1 33.33%;
      min-width: calc(100% / 3);
      max-width: calc(100% / 3);
      border-right: var(--border-thickness) solid var(--text-color);
      border-bottom: var(--border-thickness) solid var(--text-color);
      box-sizing: border-box;

      &:nth-child(3n) {
        border-right: 0;
      }

      &:nth-last-child(-n+3) {
        border-bottom: 0;
      }

      .person-header {
        display: flex;
        align-items: stretch;
        justify-content: space-between;
        border-bottom: var(--border-thickness) solid var(--text-color);
      }

      h3 {
        padding: 0.5em;
        display: flex;
        align-items: center;
        gap: 0.2em;
      }

      .busy-label {
        border-left: var(--border-thickness) solid var(--text-color);
        padding: 0.5em 1em;
        font-size: 0.8em;
        font-weight: 700;
        display: flex;
        align-items: center;

        &.resting {
          background-color: var(--magenta);
        }

        &.busy {
          background-color: var(--green);
        }

        &.idle {
          background-color: var(--gutter-grey);
        }

        &.dead {
          background-color: var(--dark-red);
        }
      }

      /* Specialization styles */
      .specialization {
        display: flex;
        align-items: center;
        gap: 1em;
        padding: 0;
        background-color: var(--light-grey);
        border-bottom: var(--border-thickness) solid var(--text-color);
        font-size: 0.8em;
        font-weight: 700;
        text-transform: uppercase;

        .lucide {
          width: 1.2em;
          height: 1.2em;
        }

        .specialization-description {
          font-weight: 400;
          font-size: 0.9em;
          text-transform: none;
          opacity: 0.8;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
          text-align: right;
          margin-left: auto;
        }

        .specialization-select {
          display: flex;
          align-items: center;
          gap: 0.5em;
          flex: 1;
          padding: 0.3em;
          flex-wrap: nowrap;
          justify-content: space-between;

          .specialization-left {
            display: flex;
            align-items: center;
            gap: 0.5em;

          }

          .specialization-icon {
            margin-top: 0;
            margin-left: 0.3em;
          }

          select.specialization-dropdown {
            padding: 0.3em 0.5em;
            border: none;
            border-right: var(--border-thickness) solid var(--text-color);
            background-color: transparent;
            color: var(--text-color);
            font-family: inherit;
            font-size: 1em;
            cursor: pointer;
            text-transform: uppercase;
            font-weight: 700;
            margin: -0.5em 0.5em -0.5em -0.5em;
            height: 100%;
            min-width: 200px;
            max-width: 150px;
            width: auto;
            flex: 0 0 auto;

            &:hover {
              background-color: var(--gutter-grey);
            }

            &:disabled {
              opacity: 0.5;
              cursor: not-allowed;
            }

            option {
              background-color: var(--background-color);
              color: var(--text-color);
            }
          }

          .specialization-description {
            flex: 1;
            margin-top: 0;
            padding-right: 0.5em;
            text-align: right;
            max-width: 50%;
          }
        }
      }

      .specialization-selection {
        padding: 0.5em;
        border-top: var(--border-thickness) solid var(--text-color);

        h4 {
          font-size: 0.8em;
          text-transform: uppercase;
          margin-bottom: 0.5em;
        }

        .specialization-buttons {
          display: flex;
          flex-wrap: wrap;
          gap: 0.5em;

          .specialization-button {
            display: flex;
            align-items: center;
            gap: 0.3em;
            padding: 0.3em 0.5em;
            font-size: 0.7em;
            text-transform: uppercase;
            border: var(--border-thickness) solid var(--text-color);
            background-color: transparent;
            cursor: pointer;
            transition: background-color 0.2s ease;

            &:hover {
              background-color: var(--light-grey);
            }

            &.active {
              background-color: var(--green);
              font-weight: 700;
            }

            .lucide {
              width: 1.2em;
              height: 1.2em;
            }
          }
        }
      }
    }


    .stats-container {
      padding: 0.5em;
    }

    .stats {
      width: 100%;
      border-collapse: collapse;
      text-transform: uppercase;
      font-size: 0.7em;

      td {
        padding: 0 0.5em;
      }

      td:nth-child(2) {
        width: 100%;
      }

      td:nth-child(3) {
        text-align: right;
        white-space: nowrap;
      }

      .progress-bar {
        height: 1em;
        background-color: var(--gutter-grey);
      }

      .progress {
        height: 100%;
        transition: width 0.3s ease-in-out, background-color 0.3s ease-in-out;

        &.high {
          background-color: var(--green);
        }

        &.medium {
          background-color: var(--light-yellow);
        }

        &.low {
          background-color: var(--dark-red);
        }
      }
    }

    .traits {
      display: none;
    }

    .person-actions {
      display: flex;
      gap: 0;
      width: 100%;
      border-top: var(--border-thickness) solid var(--text-color);

      button {
        display: flex;
        align-items: center;
        justify-content: center;
        border: 0;
        border-right: var(--border-thickness) solid var(--text-color);
        padding: 0.5em 0;
        margin: 0;
        flex: 1;
        gap: 0.5em;
        text-transform: uppercase;
        font-weight: 700;
        transition: opacity 0.3s ease, background-color 0.3s ease;

        span {
          font-size: 0.8em;
          display: flex;
          align-items: center;
          gap: 0.1em;
          font-weight: 400;
        }

        .lucide {
          padding: 0;
          width: 1em;
          height: 1em;
        }

        &:last-child {
          border-right: 0;
        }

        &:disabled {
          opacity: 0.5;
          background-color: var(--gutter-grey);
          cursor: not-allowed;

          &:hover {
            color: var(--text-color);
          }
        }
      }
    }

    @media (max-width: 100ch) {
      .person {
        flex: 1 1 100%;
        min-width: 100%;
        max-width: 100%;
        border-right: 0;
        border-top: var(--border-thickness) solid var(--text-color);
        border-bottom: var(--border-thickness) solid var(--text-color);
      }

      .person:nth-child(3n) {
        border-right: 0;
      }

      .person:first-child {
        border-top: 0;
      }

      .person:last-child {
        border-bottom: 0;
      }

      .specialization-buttons {
        flex-direction: row;
        flex-wrap: wrap;
      }
    }
  }
}


================================================
FILE: stylesheets/reset.css
================================================
a
/*
 * Modern CSS Reset
 * @link https://github.com/hankchizljaw/modern-css-reset
*/

/* Box sizing rules */
*,
*::before,
*::after {
  box-sizing: border-box;
}

/* Remove default margin */
body,
h1,
h2,
h3,
h4,
h5,
h6 {
  margin: 0;
}

p,
li,
h1,
h2,
h3,
h4 {
  /* Help prevent overflow of long words/names/URLs */
  word-break: break-word;

  /* Optional, not supported for all languages */
  /* hyphens: auto; */
}

html,
body {
  overflow-x: hidden;
}

html {
  scroll-behavior: smooth;
}

/* Set core body defaults */
body {
  min-height: 100dvh;
  font-family: sans-serif;
  font-size: 100%;
  line-height: 1.5;
  text-rendering: optimizeSpeed;
}

/* Make images easier to work with */
img {
  display: block;
  max-inline-size: 100%;
}

/* Inherit fonts for inputs and buttons */
input,
button,
textarea,
select {
  font: inherit;
}

/* Remove all animations and transitions for people that prefer not to see them */
@media (prefers-reduced-motion: reduce) {

  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }

  html {
    scroll-behavior: initial;
  }
}


================================================
FILE: stylesheets/settings.css
================================================
@import url('https://fonts.googleapis.com/css2?family=Geist+Mono:wght@100..900&display=swap');

:root {
  --text-color: #fff;
  --text-color-alt: #aaa;
  --link-color: var(--blue);
  --background-color: #000;
  --background-color-alt: #111;
  --accent-color: #4a4a4a;
  --light-red: #e06c75;
  --dark-red: #be5046;
  --green: #98c379;
  --green-rgb: 152, 195, 121;
  /* RGB values for --green */
  --light-green: #b5e890;
  --light-yellow: #e5c07b;
  --dark-yellow: #d19a66;
  --blue: #61afef;
  --magenta: #c678dd;
  --cyan: #56b6c2;
  --gutter-grey: #4b5263;
  --comment-grey: #5c6370;
  --border-thickness: 3px;
  --font-family: "Geist Mono", monospace;
  --line-height: 1.2rem;
}


================================================
FILE: stylesheets/shell.css
================================================
#game_screen {
  margin: 1em;

  header {
    display: flex;
    flex-wrap: wrap;
    justify-content: space-between;
    align-items: stretch;
    border: var(--border-thickness) solid var(--text-color);

    .logo {
      display: flex;
      align-items: stretch;
      gap: 1em;
      text-transform: uppercase;
      font-size: 1em;
      font-weight: 700;
      letter-spacing: -0.05em;

      h1 {
        display: flex;
        margin: 0;
        padding: 0;
        padding-right: 1.2rem;
        align-items: center;
        border-right: var(--border-thickness) solid var(--text-color);
      }

      .icon {
        width: 3rem;
        height: 3rem;
        padding: 0.5rem;
        border-right: var(--border-thickness) solid var(--text-color);
      }
    }

    .resources {
      display: flex;
      gap: 2em;
      font-size: 1.5em;
      font-weight: 700;

      .resource {
        display: flex;
        align-items: center;
        gap: 0.2em;
      }
    }

    .time-module {
      display: flex;
      align-items: stretch;
      border-left: var(--border-thickness) solid var(--text-color);

      .time-display {
        display: flex;
        align-items: center;
        padding: 0 1.5em;
        gap: 1em;

        &.paused {
          background-color: var(--dark-red);
        }

        .day-night-indicator {
          width: 2rem;
          height: 2rem;
          border-radius: 100%;
          background-color: var(--light-yellow);
        }

        #time {
          transition: background-color 0.3s ease;
        }
      }

      .button-container {
        display: flex;
        align-items: stretch;

        button {
          border: none;
          border-left: var(--border-thickness) solid var(--text-color);
          cursor: pointer;
          font-size: 1.5em;
          padding: 0 1em;
          margin: 0;
          display: flex;
          align-items: center;
        }
      }
    }
  }

  @media (max-width: 1100px) {
    header {
      flex-direction: column;

      .logo {
        width: 100%;
        border-bottom: var(--border-thickness) solid var(--text-color);

        h1 {
          border-right: none;
          padding-right: 0;
        }
      }

      .resources {
        width: 100%;
        justify-content: space-around;
        padding: 0.5em 0;
        gap: 0;
        border-bottom: var(--border-thickness) solid var(--text-color);
      }

      .time-module {
        width: 100%;
        border-left: none;
        flex-direction: column;

        .time-display {
          width: 100%;
          padding: 0.5em 0;
          justify-content: center;
          border-bottom: var(--border-thickness) solid var(--text-color);
        }

        .button-container {
          display: flex;
          width: 100%;

          button {
            flex: 1;
            border-left: var(--border-thickness) solid var(--text-color);
            border-top: none;
            text-align: center;
            justify-content: center;
            align-items: center;
            padding: 0.5em 0;

            &:first-child {
              border-left: none;
            }
          }
        }
      }
    }
  }

  footer {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1em;
    margin-top: 1em;
    font-weight: 700;
    letter-spacing: -0.05em;
    border: var(--border-thickness) solid var(--text-color);
  }
}


================================================
FILE: stylesheets/shortcuts.css
================================================
/* Shortcut indicators */
.shortcut {
  position: absolute;
  background: var(--text-color);
  color: var(--background-color);
  display: flex;
  align-items: center;
  justify-content: center;
  text-transform: uppercase;
  font-size: 0.65rem !important;
  font-weight: 600 !important;
}

/* Difficulty selection shortcuts */
#game_start_screen section button .shortcut {
  top: 0.5rem;
  right: 0.5rem;
  width: 1.5rem;
  height: 1.5rem;
  font-size: 0.8rem;
}

/* Button shortcuts */
.button-container button,
.action-button,
.person-actions button {
  position: relative;

  .shortcut {
    top: 0.2rem;
    right: 0.2rem;
    width: 1.2rem;
    height: 1.2rem;
    font-size: 0.7rem;
  }
}

/* Mobile view adjustments */
@media (max-width: 100ch) {
  #game_start_screen section button .shortcut {
    top: 50%;
    transform: translateY(-50%);
  }
}

/* Hide shortcuts when toggled off */
body.hide-shortcuts .shortcut {
  display: none !important;
}


================================================
FILE: stylesheets/start.css
================================================
#game_start_screen {
  text-align: left;
  margin: 0 auto;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  max-width: 700px;

  .splash_screen {
    border: var(--border-thickness) solid var(--text-color);
  }

  header {
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    font-size: 3rem;

    .icon {
      padding: 1.5rem;
      width: 4rem;
      height: 4rem;
      color: var(--dark-red);
      border-right: var(--border-thickness) solid var(--text-color);
    }

    div {
      padding: 0 1.5rem;
    }

    h1 {
      font-size: 3rem;
      font-weight: 700;
      margin: 0;
      line-height: 1em;
      letter-spacing: -0.03em;
      text-transform: uppercase;
    }

    h2 {
      font-size: 1.2rem;
      margin: 0;
    }
  }

  /* Difficulty selection */
  section {
    text-align: center;
    display: flex;

    button {
      flex: 1;
      border: 0;
      margin: 0;
      padding: 1rem;
      border-right: var(--border-thickness) solid var(--text-color);
      position: relative;

      &:last-child {
        border-right: 0;
      }

      b {
        font-weight: 700;
        text-transform: uppercase;
        font-size: 1.2rem;
      }

      div {
        margin-top: 0.5rem;
        display: flex;
        gap: 1rem;
        align-items: center;
        justify-content: center;

        span {
          display: flex;
          align-items: center;
          gap: 0.2rem;
        }

        .icon {
          width: 1rem;
          height: 1rem;
        }
      }
    }
  }

  footer {
    border-top: var(--border-thickness) solid var(--text-color);
    text-align: center;
    padding: 0 1rem;
    font-size: 0.8rem;
  }

  @media (max-width: 100ch) {
    max-width: 90%;

    header {
      h1 {
        font-size: 1.75rem;
      }

      h2 {
        font-size: 1rem;
      }
    }

    section {
      flex-direction: column;

      button {
        border-right: none;
        border-bottom: var(--border-thickness) solid var(--text-color);
        width: 100%;

        &:last-child {
          border-bottom: none;
        }
      }
    }
  }
}


================================================
FILE: stylesheets/technologies.css
================================================
/**
 * Technology Module Styles
 * Styling for the technology research tree system
 */

#technology-module {

  /* Module container styling */
  h2 {
    background-color: white;
    color: black;
    text-transform: uppercase;
    font-weight: 700;
    padding: 0.2em 0.5em;
    font-size: 0.8em;
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    gap: 0.5em;

    .lucide {
      width: 1.2em;
      height: 1.2em;
    }
  }

  /* Active research section */
  .active-research {
    border-bottom: var(--border-thickness) solid var(--text-color);
    padding: 0.8em;

    h3 {
      text-transform: uppercase;
      font-weight: 700;
      font-size: 0.9em;
      margin-bottom: 0.5em;
      display: flex;
      align-items: center;
      gap: 0.5em;

      .lucide {
        width: 1em;
        height: 1em;
        color: var(--magenta);
      }
    }

    .research-details {
      font-size: 0.8em;
      margin-bottom: 0.5em;
    }

    .progress-bar {
      height: 0.5rem;
      background-color: var(--background-color-alt);
      border: none;
      margin-bottom: 0.3em;

      .progress {
        height: 100%;
        background-color: var(--magenta);
      }
    }

    .progress-text {
      font-size: 0.7em;
      color: var(--text-color-alt);
      display: flex;
      justify-content: space-between;
    }
  }

  /* Technology category filters */
  .tech-category-filters {
    display: flex;
    border-bottom: var(--border-thickness) solid var(--text-color);

    button {
      flex: 1;
      background-color: transparent;
      border: 0;
      margin: 0;
      padding: 0.5em;
      color: var(--text-color);
      font-size: 0.8em;
      text-transform: uppercase;

      &:not(:last-child) {
        border-right: var(--border-thickness) solid var(--text-color);
      }

      &.active {
        background-color: var(--magenta);
        color: var(--background-color);
      }

      &:hover:not(.active) {
        background-color: var(--background-color-alt);
      }
    }
  }

  /* Technologies container */
  .technologies-container {
    padding: 0.8em;

    .tech-category {
      margin-bottom: 1.5em;

      h3 {
        text-transform: uppercase;
        font-weight: 700;
        font-size: 0.8em;
        margin-bottom: 0.8em;
        padding-bottom: 0.2em;
        border-bottom: var(--border-thickness) solid var(--text-color-alt);
      }
    }
  }

  /* Technology items grid */
  .tech-items {
    display: grid;
    gap: 0.8em;
    grid-template-columns: 1fr;
  }

  /* Technology item */
  .tech-item {
    background-color: var(--background-color-alt);
    border: var(--border-thickness) solid var(--text-color-alt);

    &.available {
      border-color: var(--text-color);
    }

    &.researched {
      border-color: var(--green);
    }

    &.active {
      border-color: var(--magenta);
    }

    &.locked {
      opacity: 0.6;
    }

    .tech-header {
      display: flex;
      padding: 0.5em;
      gap: 0.8em;
      align-items: center;

      .tech-icon {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 2em;
        height: 2em;
        flex-shrink: 0;

        .lucide {
          width: 1.5em;
          height: 1.5em;
          color: var(--text-color-alt);
        }
      }

      .researched & .tech-icon .lucide {
        color: var(--green);
      }

      .active & .tech-icon .lucide {
        color: var(--magenta);
      }

      .tech-name {
        flex-grow: 1;
        font-weight: 700;
        font-size: 0.9em;
        text-transform: uppercase;
      }

      .tech-status {
        font-size: 0.7em;
        padding: 0.2em 0.4em;
        border-radius: 0;
        text-transform: uppercase;
        font-weight: 700;

        &.researched {
          background-color: var(--green);
          color: var(--background-color);
        }

        &.active {
          background-color: var(--magenta);
          color: var(--background-color);
        }

        &.available {
          background-color: var(--text-color);
          color: var(--background-color);
        }

        &.locked {
          background-color: var(--text-color-alt);
          color: var(--background-color);
        }
      }
    }

    .tech-content {
      padding: 0.5em;
      border-top: var(--border-thickness) solid var(--text-color-alt);

      .tech-effect {
        font-size: 0.8em;
        margin-bottom: 0.5em;
      }

      .tech-cost {
        display: flex;
        gap: 1em;
        margin-bottom: 0.5em;
        font-size: 0.8em;

        span {
          display: flex;
          align-items: center;
          gap: 0.3em;

          .lucide {
            width: 1em;
            height: 1em;
          }
        }

        .knowledge {
          color: var(--magenta);
        }

        .time {
          color: var(--text-color-alt);
        }
      }

      .tech-prerequisites {
        font-size: 0.75em;
        color: var(--text-color-alt);
        font-style: italic;
        margin-bottom: 0.5em;
      }

      .research-button {
        background-color: var(--magenta);
        color: var(--background-color);
        border: none;
        padding: 0.3em 0.6em;
        font-size: 0.8em;
        text-transform: uppercase;
        font-weight: 700;
        cursor: pointer;

        &:hover {
          background-color: var(--text-color);
        }

        &:disabled {
          background-color: var(--text-color-alt);
          cursor: not-allowed;
          opacity: 0.7;
        }
      }

      .tech-progress {
        margin-top: 0.5em;

        .progress-bar {
          height: 0.4rem;
          background-color: var(--background-color-alt);
          border: none;
          margin-bottom: 0.2em;

          .progress {
            height: 100%;
            background-color: var(--magenta);
          }
        }

        .progress-text {
          font-size: 0.7em;
          color: var(--text-color-alt);
        }
      }
    }
  }

  /* Empty state */
  .no-technologies {
    padding: 1em;
    text-align: center;
    color: var(--text-color-alt);
    font-size: 0.9em;
    font-style: italic;
  }

  /* Responsive adjustments */
  @media (min-width: 768px) {
    .tech-items {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 768px) {
    .tech-category-filters {
      flex-wrap: wrap;

      button {
        flex: 1 0 33.333%;

        &:not(:last-child) {
          border-right: none;
        }

        &:nth-child(3n) {
          border-right: none;
        }

        &:nth-child(n+4) {
          border-top: var(--border-thickness) solid var(--text-color);
        }
      }
    }
  }
}


================================================
FILE: stylesheets/typography.css
================================================
body {
  font-family: var(--font-family);
  font-size: 16px;
  line-height: var(--line-height);
}


================================================
FILE: stylesheets/upgrades.css
================================================
#upgrades-module {
  border: var(--border-thickness) solid var(--text-color);

  h2 {
    background-color: white;
    color: black;
    text-transform: uppercase;
    font-weight: 700;
    padding: 0.2em 0.5em;
    font-size: 0.8em;
    border-bottom: var(--border-thickness) solid var(--text-color);
    display: flex;
    align-items: center;
    gap: 0.5em;
    cursor: pointer;

    .lucide {
      width: 1.2em;
      height: 1.2em;
    }
  }

  .module-content {
    max-height: 400px;
    overflow-y: auto;
    transition: max-height 0.3s ease-out;

    &.collapsed {
      max-height: 0;
      overflow: hidden;
    }
  }
}

#upgrades {
  .upgrade-button {
    width: 100%;
    margin: 0;
    border: 0;
    text-align: left;
    border-bottom: var(--border-thickness) solid var(--text-color);
    padding: 0.5em;

    &:last-child {
      border-bottom: none;
    }

    &.cannot-afford:hover {
      cursor: not-allowed;
      color: var(--text-color);
      background-color: transparent;
    }

    &.cannot-afford .upgrade-name .name,
    &.cannot-afford .upgrade-effect {
      opacity: 0.35;
    }

    &.purchased {
      cursor: default;
      background-color: var(--green);

      &:hover {
        color: var(--text-color);
      }
    }

    &.unavailable {
      opacity: 0.5;
      cursor: not-allowed;

      &:hover {
        background-color: transparent;
        color: var(--text-color);
      }
    }

    .purchased-label {
      font-size: 0.8em;
      font-weight: bold;
      color: var(--success-color);
      margin-top: 0.2em;
    }

    .builder-discount {
      font-size: 0.7em;
      font-weight: bold;
      color: var(--green);
      margin-top: 0.3em;
      display: flex;
      align-items: center;
      gap: 0.3em;

      &::before {
        content: '';
        display: inline-block;
        width: 0.8em;
        height: 0.8em;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='%2384cf9e' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M3 16l4 4'/%3E%3Cpath d='M7 20h4'/%3E%3Cpath d='M11 20v-4'/%3E%3Cpath d='M4 9l3-3'/%3E%3Cpath d='M7 3h4'/%3E%3Cpath d='M11 7v4'/%3E%3Cpath d='M15 5l4 4'/%3E%3Cpath d='M19 9v4'/%3E%3Cpath d='M15 17l4-4'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-size: contain;
      }
    }
  }

  .upgrade-name {
    text-transform: uppercase;
    font-weight: 700;
    display: flex;
    align-items: center;
    margin-bottom: 0.2em;
    justify-content: space-between;

    .name {
      display: flex;
      align-items: center;
      gap: 0.2em;
    }

    .cost {
      display: flex;
      align-items: center;
      gap: 0.2em;
      font-size: 0.8em;

      .lucide {
        width: 1em;
        height: 1em;
      }

      .discounted-cost {
        display: flex;
        align-items: center;
        gap: 0.2em;

        .original-cost {
          text-decoration: line-through;
          opacity: 0.7;
          font-size: 0.9em;
        }

        .discount-arrow {
          color: var(--green);
          font-weight: bold;
        }
      }
    }
  }

  .upgrade-effect {
    font-size: 0.8em;
  }
}


================================================
FILE: stylesheets/utils.css
================================================
.hidden {
  display: none;
}

.cursor-not-allowed {
  cursor: not-allowed;
}


================================================
FILE: stylesheets/watchtower.css
================================================
#watchtower-module {
  .countdown {
    font-size: 1.7em;
    font-weight: 700;
    text-align: center;
  }

  .mission-available {
    text-align: center;
    border-bottom: var(--border-thickness) solid var(--text-color);
    padding: 1rem 0;
    margin: 0;
  }

  .mission-options {
    button {
      margin: 0;
      border: 0;
      padding: 0.5em 1em;
      border-bottom: var(--border-thickness) solid var(--text-color);
      width: 100%;

      &:last-child {
        border-bottom: none;
      }
    }

    .easy-mission {
      background-color: var(--green);
    }

    .medium-mission {
      background-color: var(--light-yellow);
    }

    .hard-mission {
      background-color: var(--dark-red);
    }

    div {
      font-weight: 700;
      text-transform: uppercase;
    }

    span .lucide {
      width: 1em;
      height: 1em;
    }
  }

  .mission-progress {
    padding: 1rem;
    text-align: center;

    .mission-status {
      font-weight: bold;
      margin-bottom: 0.5rem;
    }

    .mission-difficulty {
      font-size: 1.2em;
      margin-bottom: 0.5rem;
    }

    .time-remaining {
      font-size: 1.1em;

      span {
        font-weight: bold;
      }
    }
  }
}


================================================
FILE: stylesheets/well.css
================================================
#well-module {
  .well-container {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }

  #well-progress {
    background-color: var(--gutter-grey);
    border-bottom: var(--border-thickness) solid var(--text-color);
    position: relative;

    #well-water {
      background-color: var(--blue);
      height: 3em;
      position: relative;
      width: 100%;
    }

    #well-level {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8em;
      z-index: 20;
    }
  }

  button {
    border: 0;
    margin: 0;
    padding: 1em;
  }
}


================================================
FILE: .cursor/rules/css.mdc
================================================
---
description: CSS rules
globs: *.css
alwaysApply: false
---
# CSS Coding Rules for Society Fail

## File Organization
- Each component or module should have its own CSS file (e.g., [farming.css](mdc:stylesheets/farming.css), [party.css](mdc:stylesheets/party.css), etc)
- Follow the existing structure in the stylesheets directory
- Core styles are split across different files:
  - [reset.css](mdc:stylesheets/reset.css) - Browser normalization
  - [base.css](mdc:stylesheets/base.css) - Foundation styles
  - [typography.css](mdc:stylesheets/typography.css) - Text styling
  - [buttons.css](mdc:stylesheets/buttons.css) - Button components
  - [shell.css](mdc:stylesheets/shell.css) - Layout structure
  - [modules.css](mdc:stylesheets/modules.css) - Module containers
  - [utils.css](mdc:stylesheets/utils.css) - Utility classes

## Modern CSS Practices
- Use CSS nesting for component structure
- Only use the `&` parent selector when necessary (avoid overuse)
- Utilize logical properties when appropriate (e.g., margin-block, padding-inline)
- Employ CSS variables for theming and recurring values
- Use modern selectors like :is() and :where() for grouping

## Naming Conventions
- Use kebab-case for class names: `.resource-container`, `.party-member`
- Use descriptive, functional names that reflect purpose
- Follow component-based naming: `.module-name__element--modifier`
- Organize classes from general to specific
- Avoid unnecessary abbreviations

## Selectors
- Keep selectors simple and focused
- Avoid deep nesting (maximum 3 levels)
- Minimize use of ID selectors (#id)
- Prefer class selectors for reusability
- Avoid overqualified selectors (e.g., div.container)

## Color System
- Use the established color palette:
  - Dark backgrounds for main UI
  - Red/dark yellow for food
  - Blue for water
  - Green for wood/nature
  - Red for errors/warnings
  - Purple/dark purple for knowledge and corruption
- Apply consistent status colors:
  - Green for positive/high
  - Yellow/orange for medium
  - Red for negative/low
- Maintain the dark, mysterious apocalyptic theme

## Layout and Sizing
- Use CSS Grid for complex layouts
- Use Flexbox for alignment and simpler layouts
- Prefer relative units (rem, em, %) over pixels
- Apply consistent spacing using the established spacing scale
- Account for various screen sizes with responsive design

## Typography
- Follow the existing typography scale in typography.css
- Use established text styles for consistency
- Maintain readability against the dark backgrounds
- Apply proper text contrast for accessibility

## Icons and Visual Elements
- Maintain consistent icon sizing within context
- Apply color classes to icons consistently:
  - .icon-dark for main icons
  - .red, .blue, .green, etc. for resource-specific icons
  - .gutter-grey for secondary icons
- Ensure proper spacing around icons
- Follow the established visual hierarchy

## Components
- Style components as self-contained units
- Use consistent styling for similar components
- Maintain clear visual states (default, hover, active, disabled)
- Use appropriate transitions for state changes
- Follow the dark theme aesthetic established in the game

## Progress Bars
- Use the established progress bar structure:
  - .progress-bar as container
  - .progress as the fill element
  - Apply appropriate modifier classes (.health-bar, .hunger-bar, etc.)
  - Include .high, .medium, .low classes for status

## Modules
- Follow the established module structure:
  - .module as the container
  - Module header with icon and title
  - Consistent internal padding
  - Clear separation between modules
- Use .module-content for the inner container
- Apply .collapsible for expandable sections

## Animation and Transitions
- Keep animations subtle and purposeful
- Use short durations (200-300ms) for UI interactions
- Apply easing functions appropriately
- Ensure animations don't interfere with gameplay
- Consider reducing motion for accessibility

## Responsive Design
- Design mobile-first, then enhance for larger screens
- Use media queries strategically
- Ensure the game is playable on different devices
- Simplify complex layouts on smaller screens
- Maintain touch-friendly target sizes on mobile (minimum 44px)

## Utilities
- Use utility classes for common patterns
- Apply consistent naming: .text-center, .flex-row, .hidden
- Keep utility classes focused on a single responsibility
- Document utility classes for team reference

## Performance
- Minimize use of expensive properties (box-shadow, filters, etc.)
- Avoid unnecessary specificity
- Use hardware acceleration for animations when appropriate
- Optimize selectors for rendering performance

## Dark Theme Considerations
- Ensure sufficient contrast for readability
- Use subtle gradients for depth
- Employ darker shades for backgrounds, lighter for interaction elements
- Apply appropriate focus states for keyboard navigation
- Maintain the post-apocalyptic atmosphere through styling


================================================
FILE: .cursor/rules/dev-rules.mdc
================================================
---
description: General rules for the AI
globs: 
alwaysApply: true
---
You are an expert AI programming assistant that primarily focuses on producing clear, readable HTML, CSS and JavaScript code.

You always use the latest versions of HTML, CSS and JavaScript, and you are familiar with the latest features and best practices.

- Use modular CSS with nesting (& should only be used when necessary)
- Use modular Javascript (ES6 modules) — This means recommending new modules/files if appropriate.
- Use Lucide icons

Use simple block comments to explain the code.

/**
 * This is a JSDoc comment block.
 * It uses the double asterisk syntax at the start.
 * Each line begins with an asterisk.
 * JSDoc comments can include special tags for documenting code.
 * 
 * @example
 * // Example usage:
 * function exampleFunction() {
 *   console.log("This function is documented with JSDoc");
 * }
 * 
 * @see {@link https://jsdoc.app/} for more information on JSDoc
 */

Use single-line comments within functions to explain the code.

CSS comments should use /* */ syntax.

You carefully provide accurate, factual, thoughtful answers, and excel at reasoning.

- Be sure to heavily comment your code (especially in Javascript) to explain your thinking and the functionality of the code so that future AI requests can understand how the pieces fit together.
- Follow the user’s requirements carefully & to the letter.
- Confirm, then write code!
- Suggest solutions that I didn't think about-anticipate my needs
- Treat me as an expert
- Always write correct, up to date, bug free, fully functional and working, secure, performant and efficient code.
- Focus on readability over being performant.
- Fully implement all requested functionality.
- Leave NO todo’s, placeholders or missing pieces.
- Don't say things like "additional logic can be added here" — instead, add the logic.
- Be concise. Minimize any other prose.
- Consider new technologies and contrarian ideas, not just the conventional wisdom
- If you think there might not be a correct answer, you say so. If you do not know the answer, say so instead of guessing.
- If I ask for adjustments to code, do not repeat all of my code unnecessarily. Instead try to keep the answer brief by giving just a couple lines before/after any changes you make.
- Always be sure any new feature that affects game state or would need to "saved" so that it exists when the user reloadsd the page are properly stored in the game's storage mechanism.


================================================
FILE: .cursor/rules/game-mechanics.mdc
================================================
---
description: Detailed game mechanics
globs: 
alwaysApply: false
---
# Society Fail - Game Mechanics Document

## Core Game Philosophy

Society Fail is a post-apocalyptic incremental game focused on survival, community building, and confronting the mysterious force that caused civilization's collapse. The game should maintain a balance between active and idle mechanics, with a dark, mysterious atmosphere that gradually reveals a deeper narrative.

### The Three Ages of Gameplay

The game progresses through three distinct phases, each with unique mechanics and challenges:

#### Age 1: Survival (Days 1-30)
- **Focus**: Basic resource gathering, immediate survival needs
- **Key Systems**: Core resources (food, water, wood), basic party management
- **Atmosphere**: Desperate, uncertain, focused on day-to-day survival
- **Challenge Scale**: Local and immediate (hunger, thirst, shelter)

#### Age 2: Community (Days 31-100)
- **Focus**: Building a sustainable settlement, specialization, exploration
- **Key Systems**: Settlement building, technologies, expeditions, factions
- **Atmosphere**: Cautiously hopeful but discovering darker threats
- **Challenge Scale**: Regional (territory control, faction relations, The Darkness)

#### Age 3: Reclamation (Days 101+)
- **Focus**: Advanced technology, understanding The Darkness, legacy
- **Key Systems**: Advanced research, artifacts, corruption manipulation
- **Atmosphere**: Revelation, confrontation with the truth
- **Challenge Scale**: Global (confronting The Darkness, determining the future)

### Core Loops

1. **Short Loop (minutes)**: Gather resources → Manage party needs → Assign tasks
2. **Medium Loop (hours)**: Build structures → Research technology → Conduct expeditions
3. **Long Loop (days)**: Expand territory → Develop faction relations → Confront The Darkness
4. **Meta Loop (full playthrough)**: Complete a cycle → Reset with memory fragments → Start new cycle with bonuses

## Resource Systems

### Primary Resources (Tier 1)

| Resource | Gathering Method | Primary Use | Storage |
|----------|------------------|-------------|---------|
| Food | Gather, Farm, Hunt | Party hunger, Crafting | Spoils over time |
| Water | Collect, Well | Party thirst, Farming | Limited base capacity |
| Wood | Chop, Lumber Mill | Buildings, Tools | Standard storage |

### Secondary Resources (Tier 2)

| Resource | Acquisition | Primary Use | Notes |
|----------|-------------|-------------|-------|
| Knowledge Points | Research, Expeditions, Actions | Technology, Special abilities | Non-physical, doesn't spoil |
| Medicine | Crafting, Expeditions | Healing, Disease prevention | Crafted from herbs and food |
| Electricity | Power generators | Advanced buildings | Cannot be stored long-term |
| Scrap Metal | Expeditions, Ruins | Advanced tools, Buildings | Found in ruins and city expeditions |
| Fuel | Expeditions, Refining | Generators, Special equipment | Limited uses, high value |

### Advanced Resources (Tier 3)

| Resource | Acquisition | Primary Use | Notes |
|----------|-------------|-------------|-------|
| Artifacts | Rare expedition finds | Unique abilities, Research | One-of-a-kind items with special powers |
| Corruption Essence | Darkness events, Rituals | Corruption manipulation, Dark technologies | Dangerous to accumulate |
| Memory Fragments | Cycle completion | Permanent upgrades | Meta-currency for prestige system |

### Resource Conversion

Resources should have conversion paths but with inefficiency to prevent trivial solutions:
- Food → Medicine (2:1 ratio)
- Wood → Fuel (3:1 ratio)
- Corruption → Knowledge (5:1 ratio, with risk)

### Resource Consumption Rates

Default consumption rates (per party member, per day):
- Food: 8 units
- Water: 6 units
- Wood (for heating/cooking): 2 units

These rates are affected by:
- Seasons (winter increases consumption)
- Technologies (efficiency upgrades reduce consumption)
- Party member traits (some consume more/less)
- Building types (better shelters reduce consumption)

## Party Member System

### Core Attributes

Each party member has the following attributes:
- Health (0-100): Physical wellbeing
- Hunger (0-100): Food satiation
- Thirst (0-100): Water satiation
- Energy (0-100): Action capacity
- Morale (0-100): Mental wellbeing
- Corruption (0-100): Influence of The Darkness

### Specializations

Party members can specialize in one of the following roles:

| Specialization | Primary Bonus | Secondary Effect | Special Ability |
|----------------|---------------|------------------|-----------------|
| Gatherer | +25% resource collection | +10% expedition loot | Quick Gathering (1-hour action for resources) |
| Builder | -20% wood cost for buildings | +10% building quality | Rapid Construction (speed up current building) |
| Researcher | +0.5 knowledge points/hour | +15% research speed | Insight (reveal random technology) |
| Fighter | +25% combat effectiveness | -10% expedition risk | Protect (reduce party damage in combat) |
| Medic | +30% medicine effectiveness | +2 health regen/day | Emergency Treatment (instant partial heal) |

### Traits System

Each party member has 1-2 traits randomly assigned at creation:

**Positive Traits:**
- Strong Back: +20% wood gathering
- Quick Learner: +30% knowledge gain
- Green Thumb: +25% farming yield
- Cautious: -15% expedition risk
- Resourceful: -10% resource consumption
- Hardy: +10% health regeneration
- Night Owl: +25% efficiency at night
- Survivor: +20% corruption resistance
- Fast Learner: +15% skill gain rate
- Leader: +5% efficiency to all party members

**Negative Traits:**
- Heavy Sleeper: +25% energy recovery time
- Big Appetite: +20% food consumption
- Pessimist: -10% morale for nearby members
- Weak Immune System: +25% illness chance
- Nervous: +15% corruption gain
- Clumsy: 5% chance to break tools
- Night Blind: -30% efficiency at night
- Wasteful: +15% resource consumption

Traits can evolve based on actions performed:
- Performing an action 50+ times can gain related positive traits
- Severe negative events can cause new negative traits
- Some technologies can remove negative traits

### Morale System

Morale affects overall efficiency:
- 76-100: +15% all actions, +5% corruption resistance
- 51-75: No modifier
- 26-50: -10% all actions, -5% corruption resistance
- 0-25: -25% all actions, -15% corruption resistance, 5% chance to refuse actions

Morale is affected by:
- Food quality and variety
- Shelter comfort
- Social activities
- Party member deaths
- Successful/failed expeditions
- Corruption level
- Season and weather

## Building and Settlement System

### Settlement Grid

The settlement exists on an expandable grid system:
- Initial grid is 5x5
- Can expand to 10x10 with appropriate technologies
- Different terrain types provide bonuses to certain buildings
- Adjacent buildings can provide synergy bonuses

### Building Categories

| Category | Function | Examples | Notes |
|----------|----------|----------|-------|
| Resource Production | Generate resources | Farm, Lumber Mill, Well | Core economy buildings |
| Storage | Increase resource capacity | Warehouse, Water Tower, Silo | Protect from spoilage/loss |
| Research | Knowledge generation | Library, Laboratory, Observatory | Enable technology advancement |
| Crafting | Create items | Workshop, Forge, Herbalist | Tool and equipment production |
| Living | Party member buffs | Dormitory, Kitchen, Recreation Room | Improve morale and recovery |
| Defense | Protection from threats | Wall, Tower, Traps | Reduce attack damage |
| Special | Unique functions | Ritual Circle, Radio Tower, Artifact Shrine | Unlock special abilities |

### Building Quality

Buildings have quality levels (1-3) that affect their efficiency:
- Level 1: Base functionality
- Level 2: +25% efficiency, +durability
- Level 3: +50% efficiency, +special ability

Quality is determined by:
- Builder specialization
- Tools used in construction
- Materials quality (standard vs. premium)

### Building Maintenance

Buildings require maintenance or they degrade:
- Wood buildings: 5% durability loss per day
- Stone buildings: 2% durability loss per day
- Metal buildings: 1% durability loss per day
- Degraded buildings operate at reduced efficiency
- Fully degraded buildings become unusable until repaired

## Research and Technology System

### Knowledge Points

Knowledge Points (KP) are gained through:
- Research actions (dedicated study)
- Expedition discoveries
- Random chance during resource gathering (5%)
- Reading recovered books
- Analyzing artifacts

### Technology Categories

| Category | Focus | Example Technologies | Unlock Potential |
|----------|-------|----------------------|------------------|
| Survival | Resource efficiency | Water Purification, Food Preservation | Reduced consumption |
| Construction | Building improvements | Better Construction, Reinforcement | Stronger, more efficient buildings |
| Medicine | Health and healing | Herbal Medicine, First Aid | Improved healing, disease prevention |
| Exploration | Expedition improvements | Mapping, Scouting Techniques | Safer, more rewarding expeditions |
| Power | Energy generation | Windmill, Water Wheel, Generator | Electricity for advanced buildings |
| Defense | Protection | Traps, Watchtower, Reinforced Walls | Reduced threat damage |
| Darkness | Corruption interaction | Corruption Containment, Dark Energy | Manipulation of The Darkness |

### Research Process

Technologies require:
- Prerequisite technologies (tech tree structure)
- Knowledge Point cost
- Sometimes physical resources
- Research time (hours/days)

Research can be accelerated by:
- Multiple researchers working together
- Reference materials from expeditions
- Specialized research buildings

## Expedition System

### Expedition Locations

Locations are discovered through:
- Exploration actions
- Scout tower detection
- Information from factions
- Story progression

Each location has:
- Distance (affecting time required)
- Difficulty rating (affecting risk)
- Resource types available
- Special discovery chance
- Encounter probability

### Expedition Process

1. **Planning Phase**
   - Select location
   - Assign party members
   - Allocate supplies (food, water, medicine)
   - Select equipment

2. **Journey Phase**
   - Automatic progression
   - Random encounters based on location
   - Resource consumption during travel

3. **Exploration Phase**
   - Resource gathering
   - Special discoveries
   - Location-specific events

4. **Return Phase**
   - Return journey (can have its own encounters)
   - Delivery of gathered resources

### Expedition Outcomes

Successful expeditions provide:
- Base resources determined by location
- Bonus resources based on party skills and equipment
- Chance for special discoveries:
  - New locations
  - Artifacts
  - Technology insights
  - New party members
  - Faction encounters

Failed expeditions result in:
- Party member injuries or death
- Loss of supplied resources
- Possible corruption increase
- Morale penalty

## The Darkness and Corruption

### The Darkness

The Darkness is the central antagonistic force:
- Caused the apocalypse (revealed through story)
- Gradually encroaches on the settlement
- Manifests through corruption and events
- Has physical presence in later game stages
- Can be understood and potentially harnessed

### Corruption Mechanics

Corruption accumulates from:
- Time passing (background rate)
- Proximity to corrupted areas
- Using certain technologies
- Failed rituals
- Some expedition encounters

Corruption effects:
- 0-25: Minor resource penalties (-5% efficiency)
- 26-50: Moderate penalties (-15% efficiency, +10% consumption)
- 51-75: Severe penalties (-30% efficiency, +25% consumption, occasional whispers)
- 76-100: Critical (random party member corruption, building degradation, The Darkness manifestations)

### Corruption Resistance

Corruption can be resisted/reduced through:
- Rituals (temporary reduction)
- Purification technologies (ongoing reduction)
- Artifacts (corruption shielding)
- Party member traits (individual resistance)
- Special buildings (area protection)

### The Whispers

The Whispers are communications from The Darkness:
- Appear more frequently at higher corruption
- Provide cryptic story information
- Sometimes offer corrupted "deals" (benefits with hidden costs)
- Can influence party member behavior
- Eventually form a coherent narrative about The Darkness

## Combat and Defense System

### Threat Types

| Threat Type | Primary Danger | Defense Type | Reward |
|-------------|----------------|--------------|--------|
| Hostile Survivors | Resource theft | Walls, Traps | Captured supplies |
| Corrupted Animals | Party injury | Hunting defenses | Food, rare materials |
| The Corrupted | Corruption increase | Purification defenses | Corruption essence |
| Dark Entities | Multiple effects | Specialized barriers | Artifacts, knowledge |

### Defense Mechanics

Defense consists of:
- Passive defenses (walls, traps)
- Active defense (party members assigned to defense)
- Special defenses (technological or artifact-based)

Defense effectiveness determined by:
- Defense structure quality and maintenance
- Defender combat abilities
- Equipment quality
- Preparation time (if threat was detected in advance)

### Combat Resolution

Combat occurs in phases:
1. **Preparation** - Assign defenders, activate defenses
2. **Engagement** - Automatic resolution with some interactive choices
3. **Resolution** - Determine outcomes, injuries, rewards

Combat factors:
- Party member combat stats
- Equipment bonuses
- Terrain advantages
- Special abilities

## Faction System

### Faction Types

The game features several distinct survivor groups:
- **The Survivors**: Pragmatic group focused on day-to-day survival (trade focus)
- **The Scientists**: Knowledge-focused faction studying the apocalypse (technology focus)
- **The Spiritualists**: Believe the apocalypse has mystical significance (ritual focus)
- **The Militarists**: Security-focused group prioritizing defense (combat focus)
- **The Reclamationists**: Focused on rebuilding civilization (building focus)

### Reputation System

Reputation levels with each faction:
- Hostile (-100 to -51): Attack on sight, no interaction
- Wary (-50 to -1): Limited trade, high prices, no cooperation
- Neutral (0 to 50): Standard trade, occasional information sharing
- Friendly (51 to 100): Favorable trade rates, cooperation, aid
- Allied (101+): Shared resources, defense pacts, special technologies

### Faction Interactions

Interactions available based on reputation:
- Trade (different specialties per faction)
- Information exchange (location discovery)
- Joint expeditions (shared risk/reward)
- Resource assistance during crises
- Technology exchange
- Defense cooperation against The Darkness

## Weather and Season System

### Seasons

Four seasons, each lasting 20 game days:
- **Spring**: +20% food/water gathering, -10% wood gathering, occasional rain
- **Summer**: +30% food gathering, -20% water gathering, heat waves
- **Fall**: +10% all resource gathering, lower corruption growth, occasional storms
- **Winter**: -30% food gathering, -10% water gathering, +30% wood consumption, cold snaps

### Weather Types

Weather changes every 6-12 hours with seasonal weighting:
- **Clear**: No modifiers (default)
- **Rainy**: +30% water gathering, -20% wood gathering, +20% farming speed
- **Windy**: -10% food gathering, +30% electricity from windmills
- **Foggy**: -15% food gathering, +10% expedition risk
- **Stormy**: -25% all gathering, +50% water gathering, +20% expedition risk

### Environmental Effects

Special environmental conditions:
- **Heat Wave**: +50% water consumption, -10% energy recovery
- **Cold Snap**: +50% wood consumption, -20% food production
- **Drought**: -50% water gathering, -30% farming speed
- **Flood**: +100% water gathering, -50% food gathering, damage to some buildings
- **Radiation Storm**: +5 corruption, party members must shelter or take damage

## Cycles and Prestige System

### Cycle Completion

A cycle can be completed through:
- Reaching day 100+ and choosing to reset
- Achieving one of the victory conditions
- Total party death (partial rewards only)

### Memory Fragments

Memory Fragments (MF) are earned based on:
- Days survived (0.5 MF per day)
- Knowledge gained (0.2 MF per point)
- Corruption resisted (0.1 MF per point)
- Technologies researched (2 MF per technology)
- Artifacts discovered (5 MF per artifact)
- Victory condition achieved (25-100 MF based on type)

### Permanent Upgrades

Memory Fragments can purchase permanent upgrades:
- **Resource Memory**: +20% starting resources per level
- **Gathering Techniques**: +10% gathering efficiency per level
- **Expedition Experience**: +15% expedition rewards per level
- **Corruption Resistance**: -10% corruption gain per level
- **Knowledge Retention**: Start with +5 knowledge per level
- **Settlement Planning**: Start with a basic building
- **Party Leadership**: Start with an additional party member
- **Technology Insight**: Start with a random technology
- **Artifact Resonance**: +10% chance to find artifacts
- **Whisper Comprehension**: More informative whispers

### Subsequent Playthroughs

Each new cycle can feature:
- Different starting conditions
- Alternative party compositions
- Unique challenges based on previous choices
- Advanced starting point (skip early game after multiple completions)
- Progressive narrative elements

## Victory Conditions

Multiple distinct paths to "winning" a cycle:

### Unity Path
- **Goal**: Unite all factions against The Darkness
- **Requirements**: Allied status with all factions, build Unity Complex
- **Challenge**: Balancing competing faction interests
- **Reward**: Maximum Memory Fragments, unique "Diplomat" bonus

### Technology Path
- **Goal**: Develop technology to counter The Darkness
- **Requirements**: Research all Darkness technologies, build Purification Array
- **Challenge**: Managing corruption while researching dark technologies
- **Reward**: High Memory Fragments, unique "Scientist" bonus

### Transcendence Path
- **Goal**: Understand and transform The Darkness
- **Requirements**: Collect all artifacts, perform the Final Ritual
- **Challenge**: Very high corruption risk, difficult artifact collection
- **Reward**: High Memory Fragments, unique "Enlightened" bonus

### Exodus Path
- **Goal**: Escape to a new, uncorrupted region
- **Requirements**: Build Expedition Vehicle, gather significant supplies
- **Challenge**: Resource-intensive, requires extensive exploration
- **Reward**: Medium Memory Fragments, unique "Pioneer" bonus

## Game Balance Principles

### Resource Equilibrium
- Resources should maintain value throughout all game phases
- New resources introduced as player masters current systems
- Conversion inefficiencies prevent trivial solutions
- Multiple paths to acquire each resource type

### Risk vs. Reward
- Higher risk activities yield better rewards
- Safety mechanisms available at efficiency cost
- Emergency measures for critical situations
- Strategic sacrifice opportunities

### Meaningful Decisions
- Choices with both benefits and drawbacks
- Mutually exclusive options that define playstyle
- Long-term consequences for short-term decisions
- Hidden information requiring exploration to discover optimal strategies

### Pacing Guidelines
- Early game (days 1-10): 5-10 minutes real time
- Mid game (days 11-50): 1-2 hours real time
- Late game (days 51-100): 3-5 hours real time
- End game (days 100+): 5+ hours real time
- Full cycle completion: 8-12 hours for experienced players

### Scaling Formulas

**Resource Gathering Base Rates**:
- Food: 5 + (day / 10) per action
- Water: 4 + (day / 12) per action
- Wood: 3 + (day / 15) per action

**Resource Consumption Base Rates**:
- Food: 2 + (party_size * 0.8) per hour
- Water: 1.5 + (party_size * 0.6) per hour
- Wood: 1 + (party_size * 0.3) per hour

**Corruption Growth**:
- Base rate: 0.1 per hour
- Modified by: party_size * 0.02 + buildings * 0.01
- Seasonal modifiers: Winter (+25%), Summer (+10%), Fall (-10%), Spring (0%)

**Expedition Rewards**:
- Base resources: location_base * (1 + (day / 100))
- Special find chance: location_chance * (1 + (knowledge / 500))

## Technical Implementation Guidelines

### State Management

The game state should be stored in a structured object:
```javascript
gameState = {
  // Core game state
  version: 5,
  day: 1,
  hour: 1,
  difficulty: "medium",
  
  // Resources
  resources: {
    food: 50,
    water: 50,
    wood: 50,
    knowledgePoints: 0,
    medicine: 0,
    electricity: 0,
    scrapMetal: 0,
    fuel: 0
  },
  
  // Resource caps
  resourceCaps: {
    food: 100,
    water: 100,
    wood: 100,
    knowledgePoints: 50,
    medicine: 20,
    electricity: 10,
    scrapMetal: 50,
    fuel: 10
  },
  
  // Advanced resources
  advancedResources: {
    artifacts: [],
    corruptionEssence: 0,
    memoryFragments: 0
  },
  
  // Party
  party: [], // Array of PartyMember objects
  
  // Settlement
  settlement: {
    buildings: [], // Array of Building objects
    grid: [], // 2D array representing the settlement layout
    unlocked: false
  },
  
  // Systems
  corruption: {
    level: 0,
    maxLevel: 100,
    rate: 0.1,
    resistance: 0
  },
  
  weather: {
    current: "clear",
    forecast: [],
    season: "spring",
    seasonDay: 1
  },
  
  expeditions: {
    active: [],
    available: [],
    completed: 0,
    discoveredLocations: []
  },
  
  research: {
    technologies: {},
    inProgress: null
  },
  
  factions: {
    discovered: [],
    reputations: {}
  },
  
  // Game progression
  gameAge: 1, // 1, 2, or 3
  prestige: {
    cyclesCompleted: 0,
    totalMemoryFragments: 0,
    permanentUpgrades: {}
  },
  
  // Statistics tracking
  stats: {
    totalResourcesGathered: {},
    totalActionsPerformed: {},
    totalBuildingsBuilt: 0,
    totalExpeditionsSent: 0,
    totalCorruptionResisted: 0,
    // etc.
  }
};
```

### Module Structure

Organize code into focused modules:
- `core.js` - Main game loop and initialization
- `resources.js` - Resource management functions
- `party.js` - Party member management
- `settlement.js` - Building and territory systems
- `research.js` - Technology and knowledge systems
- `expeditions.js` - Expedition and exploration mechanics
- `darkness.js` - Corruption and The Darkness mechanics
- `weather.js` - Season and weather systems
- `factions.js` - Faction relationships and interactions
- `combat.js` - Threat and defense systems
- `events.js` - Random and story events
- `prestige.js` - Cycle completion and Memory Fragments
- `storage.js` - Save/load functionality
- `ui.js` - User interface rendering and updates

### Scaling Considerations

As the game progresses:
- Use exponential or polynomial scaling for costs
- Apply diminishing returns to efficiency upgrades
- Ensure late-game activities remain meaningful
- Balance active and idle gameplay throughout progression
- Introduce higher tiers of content at appropriate intervals

### User Interface Guidelines

- Early-game UI should be simple and focused on basic needs
- New UI elements should be introduced gradually as systems unlock
- Critical information should always be visible
- Use consistent color coding:
  - Food: Yellow/Orange
  - Water: Blue
  - Wood: Brown/Green
  - Knowledge: Purple
  - Corruption: Dark Purple/Black
  - Positive effects: Green
  - Negative effects: Red
- Provide tooltips for all gameplay elements
- Design for both short and long play sessions

## Narrative Development

### Story Progression

The narrative unfolds through:
- The Whispers (corrupted messages)
- Dream sequences
- Expedition discoveries
- Artifact analysis
- Faction information
- Research breakthroughs

### Core Narrative Themes

- The nature of civilization and its fragility
- Humanity's relationship with knowledge and technology
- The balance between survival and progress
- The corruption of power and its consequences
- Memory and identity across time

### Story Pacing

- Early revelations should be cryptic and mysterious
- Mid-game should clarify the apocalypse's immediate causes
- Late-game reveals the true nature of The Darkness
- Final revelations depend on the player's chosen victory path
- Each cycle adds depth to the meta-narrative

## Implementation Priority

When implementing new features, follow this priority order:

1. Core mechanics that enhance the fundamental gameplay loop
2. Systems that extend game longevity and replayability
3. Features that improve strategic depth and player choice
4. Content that enriches the narrative and atmosphere
5. Quality-of-life improvements and UI enhancements


================================================
FILE: .cursor/rules/javascript.mdc
================================================
---
description: Rules for javascript
globs: *.js
alwaysApply: false
---
# JavaScript Coding Rules for Society Fail

## Module Structure
- Use ES6 modules exclusively with `import` and `export` statements
- Each file should handle a specific game system or related functionality
- Group related functions in a single module
- Export only what's needed as a public API

## Imports and Exports
- Always list imports at the top of the file
- Order imports: first external libraries, then internal modules
- Use named exports for most functions: `export function functionName() {}`
- Use default exports sparingly and only for primary module components

## State Management
- Always access game state through the `gameState` object imported from [settings.js](mdc:javascript/settings.js)
- Never modify gameState directly in a component without using appropriate update functions
- Call `updateGameState()` after making changes to sync the UI
- Call `saveGameState()` after significant changes or at appropriate intervals

## Function Organization
- Organize functions in logical groups:
  1. Initialize/setup functions at the top
  2. Core functionality functions in the middle
  3. Helper/utility functions toward the end
  4. Event handlers and UI update functions at the end
- Only expose functions that need to be public

## Documentation
- Use JSDoc comment blocks for all exported functions:
```javascript
/**
 * Description of what the function does.
 * @param {type} paramName - Description of parameter
 * @returns {type} Description of return value
 */
```
- Add single-line comments for complex logic within functions
- Include block comments before logical sections of code
- Document all state properties and their purpose

## Naming Conventions
- Use camelCase for variables and functions: `resourceAmount`, `updatePartyStats()`
- Use PascalCase for classes: `PartyMember`
- Use UPPER_SNAKE_CASE for constants: `TICK_INTERVAL`, `MAX_PARTY_SIZE`
- Prefix boolean variables with "is", "has", or similar: `isDisabled`, `hasMember`
- Be descriptive with names - avoid abbreviations except for common ones

## UI Interaction
- Add event listeners in dedicated setup functions
- Use proper event delegation when appropriate
- Update UI with dedicated `updateXXXUI()` functions
- Create and append HTML with template literals
- Use `createLucideIcons()` after adding new icons to the DOM

## Error Handling
- Validate inputs at the beginning of functions
- Check for existence of DOM elements before manipulating them
- Use console.log for development debugging, but keep these minimal in production
- Provide meaningful error messages

## Global Namespace
- Avoid polluting the global namespace
- Only expose functions to `window` when necessary for event handlers
- When exposing to window, document the reason with a comment

## HTML Generation
- Use template literals for generating HTML
- Include appropriate data attributes for event binding
- Add clear class names based on functionality

## Game Mechanics Consistency
- Follow the progression mechanics defined in [game-mechanics.mdc](mdc:.cursor/rules/game-mechanics.mdc)
- Respect resource balancing formulas
- Maintain the three-age progression system
- Keep the dark and mysterious theme consistent

## Performance Considerations
- Cache DOM selections when used repeatedly
- Batch DOM updates when possible
- Use requestAnimationFrame for animations
- Avoid unnecessary recalculations in update loops

## Styling Integration
- Use data-lucide attributes for icons
- Apply consistent CSS classes for similar elements
- Follow the color scheme defined in the stylesheets


================================================
FILE: .cursor/rules/todo.mdc
================================================
---
description: New features to implement
globs: 
alwaysApply: false
---
# Implementation Todo List for Society Fail

### 1. Add Knowledge Points Resource ✅
```
Add a new resource called "knowledge points" to the game by:
1. Modify settings.js: Add knowledgePoints: 0 to initialGameState object
2. Add totalKnowledgePointsGained: 0 for statistics tracking
3. Modify header in index.html: Add new resource div with data-lucide="book" icon and blue-purple color class
4. Update updateResourceDisplay() in game.js to include knowledge points
5. Modify all resource actions in actions.js: Add 5% chance to gain 1 knowledge point on successful resource gathering
6. Update resource actions to include: gameState.knowledgePoints += 1; gameState.totalKnowledgePointsGained += 1;
7. Add notification in log.js when knowledge points are gained
```

### 2. Implement Contentment System ✅
```
Create a contentment system that affects gameplay:
1. Create new file javascript/contentment.js with functions: initializeContentment(), increaseContentment(), decreaseContentment(), getContentmentEffects()
2. Add contentmentLevel: 50 and maxContentment: 100 to initialGameState in settings.js
3. Add contentment UI in index.html next to the day/hour/time block that makes use of lucide emoji icons with green-yellow-red color scheme
4. Update game.js to call checkContentmentEffects() in updateGameState()
5. Add logic to decrease contentment by 0.5 every 24 hours when resources fall below 10% of capacity, and increase by 0.5 when resources are above 50% capacity
6. Apply contentment effects: For each 10 points below 50 contentment, reduce resource gathering efficiency by 3%
7. Create contentmentEffects in settings.js to track specific effects
8. Add contentment messages to randomevents.js when contentment reaches certain thresholds (75, 50, 25, 0)
```

### 3. Implement Party Member Specialization System ✅
```
Add role specializations for party members:
1. Create new file javascript/specializations.js with specializationTypes object containing:
   - Gatherer: {resourceBonus: 0.25, name: "Gatherer", icon: "axe", description: "25% more resources from gathering actions"}
   - Builder: {woodCostReduction: 0.2, name: "Builder", icon: "hammer", description: "20% reduced wood cost for buildings"}
   - Researcher: {knowledgeGeneration: 0.5, name: "Researcher", icon: "book", description: "Generates 0.5 knowledge points per hour"}
2. Modify PartyMember class in party.js to add specialization: null property
3. Add setSpecialization(type) method to PartyMember class
4. Update updatePartyDisplay() in party.js to show specialization icon and name
5. Add specialization selection UI to party member display with buttons for each type
6. Modify performResourceAction() in actions.js to apply gatherer bonus
7. Modify building costs in upgrades.js to apply builder discount
8. Update updateGameState() to generate knowledge from researchers
```

### 4. Create Technology Research Tree System ✅
```
Implement a knowledge-based technology tree that extends beyond the existing Upgrades system:
1. Create new file javascript/technologies.js with TECHNOLOGIES object containing:
   - improvedTools: {id: "improvedTools", name: "Improved Tools", knowledgeCost: 10, researchTime: 4, effect: "Increase resource gathering by 20%", prerequisites: [], unlocked: false, researched: false, category: "survival"}
   - advancedFarming: {id: "advancedFarming", name: "Advanced Farming", knowledgeCost: 25, researchTime: 8, effect: "50% more food from crops", prerequisites: ["improvedTools"], unlocked: false, researched: false, category: "farming"}
   - waterPurification: {id: "waterPurification", name: "Water Purification", knowledgeCost: 25, researchTime: 8, effect: "20% less water consumption", prerequisites: ["improvedTools"], unlocked: false, researched: false, category: "survival"}
   - betterConstruction: {id: "betterConstruction", name: "Better Construction", knowledgeCost: 30, researchTime: 12, effect: "Buildings cost 25% less wood", prerequisites: ["improvedTools"], unlocked: false, researched: false, category: "building"}
   - medicinalHerbs: {id: "medicinalHerbs", name: "Medicinal Herbs", knowledgeCost: 40, researchTime: 16, effect: "Party members heal 5% health per day", prerequisites: ["advancedFarming"], unlocked: false, researched: false, category: "medicine"}
2. Add technologies: {} to initialGameState in settings.js
3. Create technology tree UI in a new section in index.html with id="technology-module"
   - Design visually distinct from Upgrades panel with connecting lines showing prerequisites
   - Include category filtering tabs
   - Show research progress for technologies being researched
4. Add functions:
   - initializeTechnologies() - Set up technology system separately from upgrades
   - startResearch(techId) - Begin research process (unlike upgrades which apply immediately)
   - updateResearchProgress() - Progress active research during tick updates
   - completeResearch(techId) - Apply effects when research time is complete
   - checkTechnologyAvailability() - Update which technologies are available based on prerequisites
   - applyTechnologyEffects() - Similar to applyUpgradeEffects() but for technologies
5. Update game.js to conditionally show the Technology module after a specific game milestone (e.g., day 10 or when player reaches certain knowledge points)
6. Connect to the time.js tick system to advance research over game time
7. Add gameState.technologies to save/load in storage.js
8. Integrate with the existing upgrade system:
   - Some technologies can unlock new upgrades
   - Some upgrades can reduce research time or costs
   - Keep both systems visible simultaneously in late game
9. Add tutorial message explaining the difference between immediate upgrades and time-based research
```

### 5. Add Expedition System for Resource Gathering
```
Create an expedition system for resource gathering:
1. Create new file javascript/expeditions.js with expedition locations:
   - nearbyForest: {id: "nearbyForest", name: "Nearby Forest", icon: "tree", resourceTypes: ["wood", "food"], baseAmount: [10, 5], riskLevel: 0.1, duration: 4, minDay: 1}
   - abandonedShop: {id: "abandonedShop", name: "Abandoned Shop", icon: "store", resourceTypes: ["food", "wood"], baseAmount: [15, 3], riskLevel: 0.2, duration: 6, minDay: 3}
   - cityRuins: {id: "cityRuins", name: "City Ruins", icon: "building", resourceTypes: ["wood", "water", "knowledgePoints"], baseAmount: [20, 15, 2], riskLevel: 0.4, duration: 12, minDay: 7}
2. Add expeditions: {activeExpeditions: [], discoveredLocations: [], completedExpeditions: 0} to initialGameState in settings.js
3. Add functions: initializeExpeditions(), startExpedition(locationId, partyMemberIndex), completeExpedition(expeditionId), calculateExpeditionOutcome(expedition)
4. Create UI for expeditions in a new section in index.html with id="expeditions-module"
5. Add UI to display available locations, send party members, and show active expeditions
6. Add logic to make party members unavailable during expeditions
7. Implement risk system: higher risk gives chance of injury/death but better rewards
8. Connect to time.js to advance expedition progress
```

### 6. Implement Settlement Building System
```
Create a settlement building system:
1. Create new file javascript/settlement.js with BUILDINGS object:
   - improvedShelter: {id: "improvedShelter", name: "Improved Shelter", icon: "home", cost: {wood: 50}, effect: "Party members recover energy 20% faster", limit: 1}
   - storageHut: {id: "storageHut", name: "Storage Hut", icon: "box", cost: {wood: 30}, effect: "Increase max resource storage by 100", limit: 3}
   - researchHut: {id: "researchHut", name: "Research Hut", icon: "book", cost: {wood: 40}, effect: "Generate 1 knowledge point per hour", limit: 1}
   - waterCollector: {id: "waterCollector", name: "Water Collector", icon: "droplet", cost: {wood: 35}, effect: "Generate 2 water per hour", limit: 2}
   - gardensPlot: {id: "gardensPlot", name: "Gardens Plot", icon: "sprout", cost: {wood: 25, water: 10}, effect: "Generate 1 food per hour", limit: 3}
2. Add settlement: {buildings: [], grid: Array(5).fill().map(() => Array(5).fill(null)), unlocked: false} to initialGameState
3. Create new UI section in index.html with id="settlement-module" with 5x5 grid
4. Add functions: initializeSettlement(), buildBuilding(id, x, y), demolishBuilding(x, y), applyBuildingEffects()
5. Add building selection UI and grid clicking mechanics
6. Connect resources to building costs
7. Implement building effects providing passive resource generation
8. Add "Settlement" tab to game modules with grid layout
```

### 7. Add Inventory and Equipment System
```
Create an inventory and equipment system:
1. Create new file javascript/inventory.js with EQUIPMENT_TYPES:
   - weapon: {slots: ["primitive", "standard", "advanced"], effectType: "gatheringBonus"}
   - tool: {slots: ["primitive", "standard", "advanced"], effectType: "resourceSpecific"}
   - clothing: {slots: ["primitive", "standard", "advanced"], effectType: "protection"}
2. Create ITEMS object:
   - primitiveAxe: {id: "primitiveAxe", name: "Primitive Axe", type: "tool", slot: "primitive", cost: {wood: 10}, effect: {wood: 0.15}, description: "+15% wood gathering"}
   - reinforcedAxe: {id: "reinforcedAxe", name: "Reinforced Axe", type: "tool", slot: "standard", cost: {wood: 30}, effect: {wood: 0.3}, description: "+30% wood gathering"}
   - huntingSpear: {id: "huntingSpear", name: "Hunting Spear", type: "weapon", slot: "primitive", cost: {wood: 15}, effect: {food: 0.2}, description: "+20% food from hunting"}
   - leatherJacket: {id: "leatherJacket", name: "Leather Jacket", type: "clothing", slot: "standard", cost: {food: 40}, effect: {protection: 0.1}, description: "10% damage reduction"}
3. Add inventory: {items: {}, equipped: {}} to each party member in PartyMember class
4. Add crafting function for items in inventory.js
5. Create inventory UI tab in party member display
6. Add equipment slots to party member display
7. Modify resource gathering to apply equipment bonuses
8. Add craftItem(itemId, partyMemberIndex) and equipItem(itemId, partyMemberIndex) functions
```

### 8. Implement Party Member Traits System
```
Develop traits system for party members:
1. Create new file javascript/traits.js with TRAITS object:
   - strongBack: {id: "strongBack", name: "Strong Back", effect: {woodGathering: 0.2}, description: "+20% wood gathering"}
   - quickLearner: {id: "quickLearner", name: "Quick Learner", effect: {knowledgeGain: 0.3}, description: "+30% knowledge gain"}
   - greenThumb: {id: "greenThumb", name: "Green Thumb", effect: {farmingYield: 0.25}, description: "+25% farming yield"}
   - cautious: {id: "cautious", name: "Cautious", effect: {expeditionRisk: -0.15}, description: "-15% expedition risk"}
   - resourceful: {id: "resourceful", name: "Resourceful", effect: {resourceConsumption: -0.1}, description: "-10% resource consumption"}
   - hardy: {id: "hardy", name: "Hardy", effect: {healthRegen: 0.1}, description: "+10% health regeneration"}
   - nightOwl: {id: "nightOwl", name: "Night Owl", effect: {nightEfficiency: 0.25}, description: "+25% efficiency at night"}
   - survivor: {id: "survivor", name: "Survivor", effect: {corruptionResistance: 0.2}, description: "+20% corruption resistance"}
   - fastLearner: {id: "fastLearner", name: "Fast Learner", effect: {skillGain: 0.15}, description: "+15% skill gain rate"}
   - leader: {id: "leader", name: "Leader", effect: {partyBonus: 0.05}, description: "+5% efficiency to all party members"}
2. Modify PartyMember constructor to randomly assign 1-2 traits from TRAITS
3. Add traits display to party member UI
4. Implement trait effects in relevant functions (resource gathering, expeditions, etc.)
5. Add functions to gain traits based on actions: gainTrait(partyMemberIndex, traitId), checkTraitTriggers()
6. Add trait evolution - traits can improve or change based on actions performed
7. Update party.js to apply trait effects to all actions
```

### 9. Create Anti-Corruption Ritual System
```
Implement rituals to counter corruption:
1. Create new file javascript/rituals.js with RITUALS object:
   - purification: {id: "purification", name: "Purification Ritual", cost: {water: 30, food: 10}, effect: {corruptionReduction: 5}, duration: 2, minMembers: 1}
   - feast: {id: "feast", name: "Community Feast", cost: {food: 50}, effect: {corruptionReduction: 8, moraleBoost: 20}, duration: 3, minMembers: 2}
   - meditation: {id: "meditation", name: "Group Meditation", cost: {}, effect: {corruptionReduction: 3, knowledgeGain: 2}, duration: 1, minMembers: 3}
   - offering: {id: "offering", name: "Resource Offering", cost: {food: 20, water: 20, wood: 20}, effect: {corruptionReduction: 12}, duration: 2, minMembers: 1}
   - ancientRite: {id: "ancientRite", name: "Ancient Rite", cost: {knowledgePoints: 10}, effect: {corruptionReduction: 15, specialReward: true}, duration: 4, minMembers: 2}
2. Add rituals: {available: [], performed: [], lastRitual: 0} to initialGameState in settings.js
3. Create ritual UI in a new section in index.html with id="rituals-module"
4. Add functions: initializeRituals(), performRitual(ritualId), completeRitual(ritualId), checkRitualAvailability()
5. Connect to corruption.js to apply corruption reduction effects
6. Make rituals require specific party members to perform
7. Add UI to show active rituals and cooldowns
8. Implement special rewards for ritual completion
```

### 10. Add Exploration Events System for Expeditions
```
Create event system for expeditions:
1. Create new file javascript/explorationEvents.js with EXPLORATION_EVENTS array containing 20+ event objects:
   - {id: "abandonedCamp", title: "Abandoned Camp", description: "You find an abandoned camp with some supplies.", choices: [{text: "Search thoroughly", outcome: {resources: {food: 5, water: 5}, risk: 0.2}}, {text: "Take what's visible and leave", outcome: {resources: {food: 2, water: 2}, risk: 0}}]}
   - {id: "strangeArtifact", title: "Strange Artifact", description: "You discover a strange glowing artifact.", choices: [{text: "Take it", outcome: {knowledgePoints: 5, corruption: 2}}, {text: "Leave it alone", outcome: {}}]}
   - {id: "injuredSurvivor", title: "Injured Survivor", description: "You find an injured person.", choices: [{text: "Help them", outcome: {newPartyMember: 0.5, resources: {food: -5}}}, {text: "Leave them", outcome: {corruption: 3}}]}
   Plus 17 more detailed events with various choices and outcomes
2. Add exploration events to expedition outcomes in expeditions.js
3. Create event resolution UI overlay for expedition system
4. Add functions: triggerExplorationEvent(expeditionId), resolveExplorationEvent(expeditionId, choiceIndex)
5. Implement choice resolution logic and outcome application
6. Create event log entries for expedition events
7. Add special rewards like unique items from certain event choices
8. Connect event outcomes to corruption, resources, and party members
```

### 11. Add Medicine Resource and Healing System
```
Implement medicine resource:
1. Modify settings.js: Add medicine: 0 to initialGameState
2. Add totalMedicineProduced: 0 for statistics tracking
3. Add new resource to header in index.html with data-lucide="pill" icon and green color class
4. Add craftMedicine() function to actions.js requiring 5 food to produce 1 medicine
5. Create healPartyMember(partyMemberIndex) function that consumes 1 medicine to restore 20 health
6. Add "Craft Medicine" button to actions panel when appropriate technology is researched
7. Add "Heal" button to party member interface when medicine is available
8. Create medicine icon and display in resources bar
9. Modify illness mechanics in randomevents.js to be treatable with medicine
10. Add medicine to storage.js for saving/loading
```

### 12. Add Dream System for Story Progression
```
Implement dream whispers system:
1. Create new file javascript/dreams.js with DREAM_FRAGMENTS array containing 30+ story elements:
   - {id: "fragment1", title: "The Beginning", content: "In your dream, you see the world before it fell...", requiresCorruption: 0}
   - {id: "fragment2", title: "The Darkness Rises", content: "Shadows moving with purpose, consuming everything...", requiresCorruption: 10}
   - {id: "fragment3", title: "The First Resistance", content: "People gathering, fighting against the inevitable...", requiresCorruption: 20}
   - Plus 27 more narrative fragments revealing game backstory
2. Add dreams: {received: []} to initialGameState
3. Create receiveDream(fragmentId) function to display dream overlay
4. Add triggers in time.js to occasionally give dreams during sleep
5. Create UI overlay for displaying dream text with atmospheric styling
6. Add dream journal UI to record discovered fragments
7. Connect corruption level to dream fragment availability
8. Make certain dreams provide gameplay hints or temporary buffs
```

### 13. Implement Seasonal Change System
```
Create seasonal system affecting gameplay:
1. Create new file javascript/seasons.js with SEASONS object:
   - spring: {id: "spring", name: "Spring", modifiers: {foodGathering: 0.2, waterGathering: 0.3, woodGathering: 0}, description: "Food and water are more plentiful.", color: "#84cf9e"}
   - summer: {id: "summer", name: "Summer", modifiers: {foodGathering: 0.3, waterGathering: -0.2, woodGathering: 0.1}, description: "Food is abundant but water is scarcer.", color: "#f7d154"}
   - fall: {id: "fall", name: "Fall", modifiers: {foodGathering: 0.1, waterGathering: 0.1, woodGathering: 0.3}, description: "Balance of resources, good for wood gathering.", color: "#d27c4a"}
   - winter: {id: "winter", name: "Winter", modifiers: {foodGathering: -0.3, waterGathering: 0, woodGathering: -0.1}, description: "Resources are scarce. Survival is harder.", color: "#9bb8ea"}
2. Add currentSeason: "spring", seasonDay: 1, seasonLength: 20 to initialGameState
3. Update time.js to advance seasons every 20 days
4. Create seasonal transition notifications and visual indicators
5. Add season display to the time module
6. Modify resource gathering functions to apply seasonal modifiers
7. Create seasonal events triggered only during specific seasons
8. Update UI colors or themes based on current season
```

### 14. Add Electricity as Power Resource
```
Implement electricity system:
1. Modify settings.js: Add electricity: 0, maxElectricity: 50 to initialGameState
2. Add electricityGeneration: 0, electricityConsumption: 0 for tracking
3. Create new file javascript/power.js with POWER_BUILDINGS:
   - windmill: {id: "windmill", name: "Windmill", cost: {wood: 100, knowledgePoints: 15}, output: 5, description: "Generates 5 electricity per hour"}
   - waterWheel: {id: "waterWheel", name: "Water Wheel", cost: {wood: 80, water: 20, knowledgePoints: 10}, output: 3, description: "Generates 3 electricity per hour"}
   - generator: {id: "generator", name: "Fuel Generator", cost: {wood: 50, knowledgePoints: 20}, output: 10, fuelCost: {wood: 2}, description: "Generates 10 electricity per hour, consumes 2 wood"}
4. Add POWER_CONSUMERS defining buildings that use electricity
5. Add electricity UI to resources display with battery icon
6. Create electricity management UI panel
7. Update time.js to generate and consume electricity each hour
8. Make advanced buildings require power to function
9. Add building status indicators for powered/unpowered
```

### 15. Create Trading Post System
```
Implement trading post:
1. Create new file javascript/trading.js with functions:
   - initializeTrading(), updateTrading(), generateTradingRates(), executeTrade(sellResource, buyResource, amount)
2. Add trading: {unlocked: false, lastUpdated: 0, currentRates: {}, specialItems: []} to initialGameState
3. Create new upgradeable building: tradingPost in settlement.js
4. Create trading UI in a new section in index.html with id="trading-module"
5. Implement resource exchange rates that update daily:
   - Base rates: 1 food = 0.8 water, 1 wood = 1.2 food, etc.
   - Daily fluctuation: Random ±20% to each rate
6. Add UI for converting between resource types
7. Create special items section for rare purchases:
   - {id: "weatherRadio", name: "Weather Radio", cost: {food: 100, electricity: 20}, effect: "Predicts weather patterns"}
   - {id: "scoutingMap", name: "Scouting Map", cost: {wood: 150}, effect: "Reveals 3 new expedition locations"}
   - {id: "medicalTextbook", name: "Medical Textbook", cost: {knowledgePoints: 40}, effect: "Improves medicine effectiveness by 25%"}
8. Make special items appear randomly every 3-5 days
```

### 16. Implement Artifact Discovery System
```
Create artifact system with special abilities:
1. Create new file javascript/artifacts.js with ARTIFACTS array:
   - {id: "ancientCompass", name: "Ancient Compass", description: "Reduces expedition time by 25%", effect: {expeditionTimeFactor: 0.75}}
   - {id: "mysteriousAmulet", name: "Mysterious Amulet", description: "Reduces corruption gain by 15%", effect: {corruptionFactor: 0.85}}
   - {id: "crystalLens", name: "Crystal Lens", description: "Increases knowledge gain by 30%", effect: {knowledgeFactor: 1.3}}
   - {id: "ancientSeedPouch", name: "Ancient Seed Pouch", description: "Farming yields 40% more food", effect: {farmingFactor: 1.4}}
   - {id: "waterPendant", name: "Water Pendant", description: "Water collection improved by 35%", effect: {waterFactor: 1.35}}
   - {id: "woodcarverTools", name: "Woodcarver's Tools", description: "Wood gathering improved by 35%", effect: {woodFactor: 1.35}}
   - {id: "healingChalice", name: "Healing Chalice", description: "Medicine effectiveness improved by 50%", effect: {medicineFactor: 1.5}}
   - {id: "darknessVessel", name: "Darkness Vessel", description: "Converts corruption into knowledge", effect: {specialAbility: "convertCorruption"}}
   - {id: "ancientTablet", name: "Ancient Tablet", description: "Reveals all technologies", effect: {specialAbility: "revealTech"}}
   - {id: "timepiece", name: "Mysterious Timepiece", description: "Occasionally freezes time for free actions", effect: {specialAbility: "freezeTime"}}
2. Add artifacts: {discovered: []} to initialGameState
3. Create artifact collection UI in a new section
4. Add artifact discovery to expedition events with 5% chance
5. Create discoverArtifact(artifactId) and useArtifactAbility(artifactId) functions
6. Add artifact effects to appropriate game systems
7. Create special UI for artifacts with unique abilities
8. Implement artifacts as modifiers to existing mechanics
```

### 17. Create Emergency Resource Management System
```
Implement emergency resource protocols:
1. Create new file javascript/emergency.js with functions:
   - activateRationing(resourceType), deactivateRationing(resourceType)
   - initiateEmergencyGathering(resourceType), endEmergencyGathering(resourceType)
   - implementDesperateMeasures(measureType)
2. Add emergency: {rationing: {food: false, water: false}, emergencyGathering: {}, desperateMeasuresUsed: []} to initialGameState
3. Create UI for emergency protocols in a dropdown menu from resources display
4. Implement rationing system:
   - Reduces resource consumption by 30%
   - Causes 2 morale loss per hour to all party members
   - Slows energy recovery by 25%
5. Add "Emergency Gathering" option:
   - Doubles resource gain rate for 12 hours
   - Causes permanent 5% efficiency loss afterward
   - Depletes party member energy at triple rate
6. Add "Desperate Measures" actions:
   - "Sacrifice Health": Convert party member health to energy
   - "Burn Supplies": Convert wood to warmth (useful in winter)
   - "Dark Pact": Convert health to corruption reduction
7. Create confirmation dialogs for emergency actions
```

### 18. Add Faction Relationship System
```
Implement faction system:
1. Create new file javascript/factions.js with FACTIONS object:
   - survivors: {id: "survivors", name: "The Survivors", description: "Pragmatic group focused on day-to-day survival", baseAttitude: 0, reputation: 0, tradeBonuses: {food: 0.1}}
   - scientists: {id: "scientists", name: "The Scientists", description: "Knowledge-focused faction studying the apocalypse", baseAttitude: -10, reputation: 0, tradeBonuses: {knowledgePoints: 0.2}}
   - spiritualists: {id: "spiritualists", name: "The Spiritualists", description: "Believe the apocalypse has mystical significance", baseAttitude: 10, reputation: 0, tradeBonuses: {corruption: -0.05}}
2. Add factions: {discovered: [], interactions: {}} to initialGameState
3. Create factions UI in a new section in index.html with id="factions-module"
4. Implement reputation system with 5 levels: Hostile, Wary, Neutral, Friendly, Allied
5. Add functions: discoverFaction(factionId), changeFactionReputation(factionId, amount)
6. Create faction-specific trading bonuses based on reputation
7. Implement faction discovery through expeditions with 10% chance
8. Add faction-specific quests and requests
```

### 19. Create Achievement System with Permanent Benefits
```
Expand achievements system with permanent benefits:
1. Modify achievements.js to update ACHIEVEMENTS array with new achievements:
   - longTermSurvivor: {id: "longTermSurvivor", name: "Century Survivor", description: "Survive for 100 days", condition: state => state.day >= 100, reward: {resourceGatheringBonus: 0.05}}
   - masterCrafter: {id: "masterCrafter", name: "Master Crafter", description: "Craft 50 tools", condition: state => state.totalItemsCrafted >= 50, reward: {craftingCostReduction: 0.1}}
   - darkExplorer: {id: "darkExplorer", name: "Dark Explorer", description: "Complete 30 expeditions", condition: state => state.expeditions.completedExpeditions >= 30, reward: {expeditionTimeReduction: 0.1}}
   - knowledgeSeeker: {id: "knowledgeSeeker", name: "Knowledge Seeker", description: "Research 15 technologies", condition: state => Object.values(state.technologies).filter(t => t.researched).length >= 15, reward: {knowledgeGainBonus: 0.15}}
   - masterFarmer: {id: "masterFarmer", name: "Master Farmer", description: "Harvest 500 food from farming", condition: state => state.totalFoodFromFarming >= 500, reward: {farmingYieldBonus: 0.1}}
   Add 15 more achievements with specific conditions and rewards
2. Modify unlockAchievement() to apply permanent bonuses in achievements.js
3. Add achievement progress tracking to relevant game actions
4. Create new UI panel showing achievement progress and rewards
5. Add achievement notification with reward details
6. Implement persistent achievement bonuses affecting gameplay
7. Add achievement reset options with memory fragment compensation
```

### 20. Create Memory Fragment Prestige System
```
Implement memory fragment prestige system:
1. Create new file javascript/prestige.js with functions:
   - calculateMemoryFragments(), resetWithMemoryFragments(), applyMemoryFragmentUpgrades()
2. Add prestige: {memoryFragments: 0, totalReset: 0, upgrades: {}} to initialGameState
3. Create MEMORY_UPGRADES object:
   - startingResources: {id: "startingResources", name: "Resource Memory", cost: 10, levels: 5, effect: level => ({startingResourceBonus: level * 0.2})}
   - efficientGathering: {id: "efficientGathering", name: "Gathering Techniques", cost: 15, levels: 5, effect: level => ({gatheringEfficiency: level * 0.1})}
   - expeditionExperience: {id: "expeditionExperience", name: "Expedition Experience", cost: 20, levels: 3, effect: level => ({expeditionRewards: level * 0.15})}
   - corruptionResistance: {id: "corruptionResistance", name: "Corruption Resistance", cost: 25, levels: 3, effect: level => ({corruptionGainReduction: level * 0.1})}
   - knowledgeRetention: {id: "knowledgeRetention", name: "Knowledge Retention", cost: 30, levels: 3, effect: level => ({startingKnowledge: level * 5})}
   Plus 5 more upgrades
4. Create prestige UI in a new section accessed via a special button
5. Make reset available after day 100 with confirmation dialog
6. Calculate fragments based on: days survived (0.5 per day), knowledge gained (0.2 per point), corruption resisted (0.1 per point)
7. Create "New Game+" system with special options for subsequent playthroughs
8. Add permanent upgrade system purchasable with fragments
```

### 21. Implement Resource Storage Building System
```
Create storage buildings for resources:
1. Add to the BUILDINGS object in settlement.js:
   - foodStorage: {id: "foodStorage", name: "Food Storage", icon: "package", cost: {wood: 80}, effect: {foodCapacity: 500}, description: "Store up to 500 additional food"}
   - waterReservoir: {id: "waterReservoir", name: "Water Reservoir", icon: "container", cost: {wood: 70, knowledgePoints: 5}, effect: {waterCapacity: 500}, description: "Store up to 500 additional water"}
   - woodshed: {id: "woodshed", name: "Woodshed", icon: "logs", cost: {wood: 50}, effect: {woodCapacity: 400}, description: "Store up to 400 additional wood"}
   - libraryShelf: {id: "libraryShelf", name: "Library Shelf", icon: "book", cost: {wood: 60, knowledgePoints: 10}, effect: {knowledgeCapacity: 100}, description: "Store up to 100 additional knowledge points"}
2. Add storage capacity tracking to gameState: {maxFood: 100, maxWater: 100, maxWood: 100, maxKnowledge: 50}
3. Update resource limits in all resource-related functions
4. Create resource warning notifications when approaching capacity
5. Add storage tab to building interface
6. Implement storage efficiency upgrades research options
7. Add visuals showing current/max resource capacity in UI
8. Update storage in storage.js for save/load
```

### 22. Add Weather System Affecting Gameplay
```
Implement weather system:
1. Create new file javascript/weather.js with WEATHER_TYPES:
   - clear: {id: "clear", name: "Clear", icon: "sun", modifiers: {}, description: "Perfect weather for all activities"}
   - rainy: {id: "rainy", name: "Rainy", icon: "cloud-rain", modifiers: {woodGathering: -0.2, waterGathering: 0.3, farmingSpeed: 0.2}, description: "Good for water collection, bad for wood gathering"}
   - windy: {id: "windy", name: "Windy", icon: "wind", modifiers: {foodGathering: -0.1, electricityGeneration: 0.3}, description: "Windmills generate more electricity"}
   - foggy: {id: "foggy", name: "Foggy", icon: "cloud-fog", modifiers: {expeditionRisk: 0.1, foodGathering: -0.15}, description: "Increased expedition risk"}
   - stormy: {id: "stormy", name: "Stormy", icon: "cloud-lightning", modifiers: {allGathering: -0.25, waterGathering: 0.5, expeditionRisk: 0.2}, description: "Dangerous for expeditions, good for water"}
2. Add weather: {current: "clear", forecast: [], lastChange: 0} to initialGameState
3. Create functions: updateWeather(), forecastWeather(), getWeatherEffects()
4. Add weather icon and display to the time module
5. Implement weather changes every 6-12 hours with weighted probabilities
6. Create seasonal weather patterns (more rain in spring, etc.)
7. Add weather forecast research technology
8. Modify resource gathering and expeditions to account for weather
```

### 23. Implement Tool Crafting System
```
Create tool crafting system:
1. Create new file javascript/crafting.js with TOOLS object:
   - basicAxe: {id: "basicAxe", name: "Basic Axe", type: "wood", cost: {wood: 15}, durability: 20, bonus: 0.2, description: "+20% wood gathering, 20 uses"}
   - sturdyAxe: {id: "sturdyAxe", name: "Sturdy Axe", type: "wood", cost: {wood: 30}, durability: 40, bonus: 0.4, description: "+40% wood gathering, 40 uses"}
   - fishingSpear: {id: "fishingSpear", name: "Fishing Spear", type: "food", cost: {wood: 20}, durability: 15, bonus: 0.3, description: "+30% food gathering, 15 uses"}
   - waterFilter: {id: "waterFilter", name: "Water Filter", type: "water", cost: {wood: 10, knowledgePoints: 5}, durability: 25, bonus: 0.25, description: "+25% water gathering, 25 uses"}
   - researchJournal: {id: "researchJournal", name: "Research Journal", type: "knowledge", cost: {wood: 20}, durability: 10, bonus: 0.5, description: "+50% knowledge gain, 10 uses"}
2. Add tools: {crafted: [], active: {}} to gameState
3. Create crafting UI in a new section in index.html
4. Add functions: craftTool(toolId), useTool(toolId, resourceType), checkToolDurability()
5. Implement tool degradation system
6. Update resource gathering to check for and use appropriate tools
7. Add crafting tab to main UI
8. Implement technology to improve tool durability and effectiveness
```

### 24. Add Party Member Morale System
```
Implement morale system for party members:
1. Modify PartyMember class in party.js to add morale: 100 property
2. Add moraleEffects tracking impact on actions
3. Create functions in party.js: updateMorale(), getMoraleEffects(), adjustMorale(partyMemberIndex, amount)
4. Add morale display bar to party member UI
5. Implement morale effects:
   - >75 morale: +15% all resource gathering
   - 50-75 morale: No modifier
   - 25-50 morale: -10% all resource gathering
   - <25 morale: -25% all resource gathering, 5% chance to refuse actions
6. Add morale-impacting events:
   - Good meals: +5 morale
   - Resource scarcity: -3 morale per day
   - Successful expeditions: +10 morale
   - Party member death: -20 morale to all
   - Comfortable shelter: +2 morale per day
7. Create morale-boosting actions (games, celebration, etc.)
8. Add morale threshold system for more varied effects
```

### 25. Implement Day/Night Cycle System
```
Create day/night cycle system:
1. Modify time.js to track day/night:
   - Hours 6-18 are day
   - Hours 19-5 are night
2. Add visual indicator in UI for day/night
3. Add isNight() function to time.js
4. Update core.css to add night-time styling
5. Implement activity modifiers based on time:
   - Night: -20% food/wood gathering, +10% water gathering
   - Night: +25% corruption growth rate
   - Night: -10% energy consumption while resting
   - Day: Normal resource gathering rates
6. Add day/night-specific random events
7. Create upgrades that reduce night penalties
8. Implement special night exploration events with higher risks/rewards
9. Add lighting buildings to reduce night penalties
10. Create specialized night vision equipment
```

### 26. Add Herb Garden for Medicine Production
```
Implement herb garden for medicine:
1. Create new file javascript/herbs.js with HERBS object:
   - healroot: {id: "healroot", name: "Healroot", growthTime: 12, yield: 2, effect: {medicineValue: 1}}
   - feverfew: {id: "feverfew", name: "Feverfew", growthTime: 18, yield: 3, effect: {medicineValue: 1.5}}
   - bloodleaf: {id: "bloodleaf", name: "Bloodleaf", growthTime: 24, yield: 4, effect: {medicineValue: 2}}
2. Add herbs: {available: {}, growing: [], harvested: {}} to initialGameState
3. Create herb garden UI in a new section or tab in the farming module
4. Add functions: plantHerb(herbId, plotIndex), harvestHerb(plotIndex), processHerbs(herbId, amount)
5. Implement herb garden building in settlement.js
6. Connect herbs to medicine crafting in a 2:1 ratio (2 herbs = 1 medicine)
7. Add herb discovery from expeditions
8. Implement herb seeds as tradable items
9. Create herb garden upgrade to increase yield
10. Add herb garden plot system similar to farming
```

### 27. Create Scout Tower Defense System
```
Implement scout tower for threat detection:
1. Create new file javascript/defense.js with THREAT_TYPES:
   - hostileSurvivors: {id: "hostileSurvivors", name: "Hostile Survivors", risk: 0.3, damage: {resources: 0.1, health: 20}, difficulty: 1}
   - corruptedAnimals: {id: "corruptedAnimals", name: "Corrupted Animals", risk: 0.4, damage: {health: 30}, difficulty: 2}
   - darkEntities: {id: "darkEntities", name: "Dark Entities", risk: 0.6, damage: {corruption: 5, health: 15}, difficulty: 3}
2. Add defense: {towers: [], detectedThreats: [], lastThreat: 0} to initialGameState
3. Add scout tower building to BUILDINGS in settlement.js
4. Create defense UI in a new section showing potential threats
5. Add functions: detectThreats(), handleThreat(threatId), prepareDefense()
6. Implement threat warning system with 6-hour advance notice
7. Create defense mechanics for each threat type
8. Add defensive equipment types to inventory.js
9. Implement tower upgrades for better detection
10. Add party member assignment to defense duties
```

### 28. Add Basic Combat System
```
Implement simple combat system:
1. Create new file javascript/combat.js with functions:
   - initiateCombat(threatType, partyMembers), resolveCombatRound(), endCombat()
2. Add combat: {inProgress: false, currentThreat: null, assignedDefenders: []} to initialGameState
3. Create combat UI overlay for threat defense
4. Update PartyMember class to add combat stats:
   - attackPower: 10 + random(5)
   - defense: 5 + random(5)
   - accuracy: 0.7 + random(0.2)
5. Add combat equipment types to affect stats
6. Implement combat resolution with 3 phases:
   - Preparation (assign members, use items)
   - Combat (automatic calculation with some randomness)
   - Aftermath (injuries, rewards)
7. Add resource rewards for successful defense
8. Create injury system with medicine healing
9. Implement weapon and armor crafting
10. Add combat training to improve stats
```

### 29. Add Resource Consumption Optimization System
```
Create resource optimization system:
1. Create new file javascript/optimization.js with OPTIMIZATION_UPGRADES:
   - efficientCooking: {id: "efficientCooking", name: "Efficient Cooking", cost: {food: 100, knowledgePoints: 15}, effect: {foodConsumptionReduction: 0.15}}
   - waterRecycling: {id: "waterRecycling", name: "Water Recycling", cost: {water: 100, knowledgePoints: 15}, effect: {waterConsumptionReduction: 0.15}}
   - insulatedShelter: {id: "insulatedShelter", name: "Insulated Shelter", cost: {wood: 120, knowledgePoints: 10}, effect: {energyConsumptionReduction: 0.1}}
   - preservationTechniques: {id: "preservationTechniques", name: "Preservation Techniques", cost: {food: 80, knowledgePoints: 20}, effect: {foodSpoilageReduction: 0.5}}
2. Add optimization: {upgrades: {}, efficiency: {food: 1, water: 1, energy: 1}} to initialGameState
3. Create optimization UI in upgrades panel
4. Add functions: purchaseOptimization(upgradeId), applyOptimizationEffects()
5. Create efficiency display showing current consumption rates
6. Update resource consumption to apply optimization effects
7. Add technology prerequisites for optimization upgrades
8. Implement cumulative optimization effects
9. Create resource consumption breakdown statistics
10. Add resource usage analytics display
```

### 30. Implement Story-Based Special Events
```
Create major story events system:
1. Create new file javascript/storyEvents.js with STORY_EVENTS array:
   - {id: "firstContact", title: "First Contact", trigger: state => state.factions.discovered.length > 0, content: "A faction has noticed your settlement...", choices: [{text: "Approach cautiously", outcome: {reputation: 5}}, {text: "Prepare defenses", outcome: {reputation: -5, corruptionReduction: 2}}]}
   - {id: "darkWhispers", title: "Dark Whispers", trigger: state => state.corruptionLevel >= 25, content: "The darkness is starting to manifest physically...", choices: [{text: "Study it", outcome: {knowledgePoints: 10, corruption: 5}}, {text: "Perform cleansing ritual", outcome: {corruption: -10, resources: {food: -20, water: -20}}}]}
   - {id: "ancientLibrary", title: "Ancient Library", trigger: state => state.expeditions.completedExpeditions >= 10, content: "You've discovered an intact pre-apocalypse library...", choices: [{text: "Recover knowledge", outcome: {knowledgePoints: 30, specialTech: 'preservation'}}, {text: "Search for survival guides", outcome: {resourceGatheringBonus: 0.1}}]}
   - Add 7 more detailed story events with choices and outcomes
2. Add storyEvents: {completed: [], available: []} to initialGameState
3. Create story event UI overlay with atmospheric styling
4. Add functions: checkStoryEvents(), triggerStoryEvent(eventId), resolveStoryEvent(eventId, choiceIndex)
5. Implement story event triggers based on game progress
6. Create meaningful choice outcomes affecting gameplay
7. Add special rewards unique to story events
8. Implement consecutive story chains requiring specific choices
9. Create visual indicators for available story events
10. Add story recap section in game UI
```

